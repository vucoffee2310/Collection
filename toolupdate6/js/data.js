// Default JSON data - replace with your actual data structure
export const jsonData = {
  "page_1": [
    {
      "[y1, x1, y2, x2]": [90, 142, 172, 856],
      "text": "dựa trên dữ liệu lỗi thời, không đầy đủ hoặc được kiểm duyệt kém có nhiều khả năng tạo ra thông tin sai lệch. Các quy trình kiểm thử phải đảm bảo rằng tác tử luôn lấy dữ liệu từ các nguồn chính xác, phù hợp và cập nhật. Ví dụ, một AI tóm tắt các bài báo nên dựa vào các ấn phẩm đáng tin cậy, có uy tín và tránh các nguồn chưa được xác minh."
    },
    {
      "[y1, x1, y2, x2]": [188, 142, 312, 856],
      "text": "Các cơ chế phản hồi là rất cần thiết để phát hiện và giải quyết ảo giác. Các hệ thống này giám sát đầu ra của tác tử, đánh dấu những điểm không chính xác để xem xét và sửa chữa. Vòng lặp phản hồi có sự tham gia của con người (Human-in-the-loop) có thể đặc biệt hiệu quả, cho phép các chuyên gia trong lĩnh vực tinh chỉnh các phản hồi của hệ thống theo thời gian. Trong các ứng dụng động, các cơ chế phản hồi tự động có thể xác định sự khác biệt giữa dự đoán của tác tử và kết quả thực tế, kích hoạt các bản cập nhật cho mô hình hoặc nguồn dữ liệu để cải thiện độ tin cậy."
    },
    {
      "[y1, x1, y2, x2]": [328, 142, 510, 856],
      "text": "Các biện pháp giảm thiểu ảo giác đã phát triển để nhấn mạnh các vòng lặp phản hồi kết hợp giữa con người và AI, nơi các chuyên gia trong lĩnh vực hợp tác với các hệ thống AI để giám sát theo thời gian thực—chẳng hạn như trong các kịch bản tự cứu hộ trong khủng hoảng—để tinh chỉnh đầu ra, giảm tải nhận thức cho người dùng và sửa chữa các thông tin bịa đặt trước khi chúng lan truyền. Cách tiếp cận này tích hợp phát hiện tự động với sự phán đoán của con người, nâng cao độ tin cậy trong các ứng dụng có tính rủi ro cao như chăm sóc sức khỏe hoặc tư vấn pháp lý. Ngoài ra, các đánh giá có ý thức về chi phí đang ngày càng được chú ý, tập trung vào việc cân bằng giữa việc giảm ảo giác và chi phí suy luận; ví dụ, các khung công tác hiện nay định lượng “chi phí ảo giác” thông qua các chỉ số cân nhắc giữa cải thiện độ chính xác và chi phí tính toán, cho phép triển khai hiệu quả hơn mà không làm giảm hiệu suất."
    },
    {
      "[y1, x1, y2, x2]": [526, 142, 633, 856],
      "text": "Bằng cách ưu tiên độ chính xác của nội dung, thực thi sự phụ thuộc vào dữ liệu, tận dụng các cơ chế phản hồi và kiểm thử nghiêm ngặt cho các kịch bản đa dạng, các nhà phát triển có thể giảm thiểu nguy cơ ảo giác và xây dựng các tác tử cung cấp đầu ra đáng tin cậy, có cơ sở và đáng tin cậy. Cách tiếp cận có kỷ luật này đảm bảo rằng hệ thống hoạt động như một đối tác đáng tin cậy trong lĩnh vực dự kiến, đáp ứng mong đợi của người dùng và tuân thủ các tiêu chuẩn cao về độ chính xác và tính toàn vẹn."
    },
    {
      "[y1, x1, y2, x2]": [664, 142, 683, 456],
      "text": "Xử lý các đầu vào không mong muốn"
    },
    {
      "[y1, x1, y2, x2]": [700, 142, 807, 856],
      "text": "Môi trường thực tế là không thể đoán trước, và các tác tử phải mạnh mẽ khi đối mặt với các đầu vào không lường trước, không đúng định dạng hoặc thậm chí là độc hại. Các bài kiểm thử tích hợp trong lĩnh vực này cố tình cung cấp các đầu vào nằm ngoài các giả định huấn luyện hoặc thiết kế—chẳng hạn như các định dạng dữ liệu không mong muốn, tiếng lóng hoặc lỗi chính tả trong ngôn ngữ người dùng, hoặc các lỗi một phần của các dịch vụ bên ngoài. Mục tiêu là đảm bảo rằng tác tử không bị treo cũng không tạo ra các đầu ra có hại, mà thay vào đó phản hồi một cách lịch sự: bằng cách làm rõ, từ chối hoặc leo thang khi thích hợp."
    },
    {
      "[y1, x1, y2, x2]": [823, 142, 876, 856],
      "text": "Trong bối cảnh tác tử thương mại điện tử của chúng tôi, các đầu vào không mong muốn có thể bao gồm các ID đơn hàng không đúng định dạng (ví dụ: lỗi chính tả trong \"A89268\" khi hoàn tiền cho một chiếc cốc bị nứt) hoặc các yêu cầu mơ hồ kết hợp nhiều ý định (như trong cancel_4_refund, nơi một yêu cầu hủy được đưa ra"
    },
    {
      "[y1, x1, y2, x2]": [925, 684, 938, 856],
      "text": "Đánh giá Toàn diện | 219"
    }
  ],
  "page_2": [
    {
      "[y1, x1, y2, x2]": [90, 142, 157, 856],
      "text": "cho một đơn hàng đã giao), yêu cầu tác tử phải làm rõ hoặc leo thang thay vì tiếp tục với các lệnh gọi công cụ sai lầm như issue_refund. Việc kiểm thử có hệ thống với các biến thể đối nghịch từ các bộ đánh giá của chúng tôi, chẳng hạn như chèn tiếng lóng hoặc lỗi một phần trong việc tải ảnh lên, đảm bảo việc xử lý một cách lịch sự mà không làm rò rỉ thông tin đơn hàng nhạy cảm."
    },
    {
      "[y1, x1, y2, x2]": [173, 142, 297, 856],
      "text": "Kiểm thử tích hợp hiệu quả không chỉ bao gồm việc “fuzzing” ngẫu nhiên các đầu vào mà còn là việc khám phá có hệ thống các trường hợp biên được thông báo bởi các sự cố lịch sử hoặc phân tích đối nghịch. Đối với các ứng dụng quan trọng về an toàn, điều quan trọng là phải xác minh rằng, ngay cả khi chịu áp lực, tác tử cũng không làm rò rỉ thông tin nhạy cảm, vi phạm chính sách hoặc gây ra các lỗi ở các khâu sau. Bằng cách liên tục mở rộng và tinh chỉnh các bài kiểm thử này khi tác tử phát triển, các nhà phát triển có thể xây dựng các hệ thống mạnh mẽ, đáng tin cậy và sẵn sàng cho sự phức tạp của thế giới thực."
    },
    {
      "[y1, x1, y2, x2]": [328, 142, 347, 471],
      "text": "Chuẩn bị Triển khai"
    },
    {
      "[y1, x1, y2, x2]": [364, 142, 454, 856],
      "text": "Khi một hệ thống tác tử trưởng thành, việc chuyển từ giai đoạn phát triển sang triển khai đòi hỏi các bước kiểm tra sẵn sàng và các cổng chất lượng có kỷ luật để đảm bảo độ tin cậy và sự đáng tin cậy trong môi trường sản xuất. Sự sẵn sàng cho sản xuất không chỉ là việc vượt qua các bài kiểm thử—đó là một đánh giá toàn diện về việc liệu hệ thống có thể thực hiện chức năng dự kiến của nó một cách an toàn, nhất quán và hiệu quả trong môi trường thực tế hay không."
    },
    {
      "[y1, x1, y2, x2]": [470, 142, 618, 856],
      "text": "Thiết lập các tiêu chí triển khai rõ ràng là bước đầu tiên. Các tiêu chí này thường bao gồm việc đáp ứng các ngưỡng hiệu suất định lượng trên các bộ đánh giá liên quan, chứng minh sự ổn định dưới áp lực và các trường hợp biên, và xác nhận rằng tất cả các luồng công việc cốt lõi hoạt động như dự kiến. Trong thực tế, các nhóm nên sử dụng các danh sách kiểm tra có cấu trúc để xác nhận rằng tất cả các thành phần—công cụ, lập kế hoạch, bộ nhớ, học tập và tích hợp—đã được kiểm thử và xem xét một cách nghiêm ngặt. Các tiêu chí chính có thể bao gồm việc vượt qua các bài kiểm thử tích hợp từ đầu đến cuối, đáp ứng các mục tiêu về độ trễ và thời gian hoạt động, và xác minh không có lỗi nghiêm trọng hoặc có mức độ nghiêm trọng cao."
    },
    {
      "[y1, x1, y2, x2]": [634, 142, 758, 856],
      "text": "Đối với tác tử hỗ trợ khách hàng đang hoạt động của chúng tôi, các tiêu chí triển khai có thể bao gồm việc đạt được ít nhất 95% độ chính xác trong việc gọi công cụ cho các kịch bản hoàn tiền và hủy đơn (ví dụ: gọi đúng issue_refund cho các mặt hàng bị hỏng như chiếc cốc bị nứt trong đơn hàng có ID A89268), với các cổng tự động chặn việc quảng bá nếu có sự suy giảm trong các bài kiểm thử nhiều lượt như sửa đổi địa chỉ (modify_5). Quá trình này, kết hợp với việc giám sát thí điểm cho các biến thể trong thế giới thực, cho phép triển khai một cách tự tin đồng thời cho phép quay lui nhanh chóng nếu có vấn đề phát sinh trong sản xuất."
    },
    {
      "[y1, x1, y2, x2]": [774, 142, 898, 856],
      "text": "Một cơ chế quan trọng để thực thi các tiêu chí này là việc sử dụng các cơ chế cổng (gating). Cổng là các bước kiểm tra tự động hoặc thủ công ngăn chặn việc quảng bá lên môi trường sản xuất trừ khi tất cả các yêu cầu được đáp ứng. Điều này có thể bao gồm việc chặn triển khai nếu phát hiện bất kỳ sự suy giảm nào trên bộ đánh giá mới nhất, hoặc yêu cầu sự chấp thuận rõ ràng từ các trưởng nhóm kỹ thuật và sản phẩm sau một giai đoạn thí điểm hoặc beta thành công. Các cổng có thể được cấu hình để leo thang các vấn đề cho con người xem xét khi kết quả tự động không rõ ràng."
    },
    {
      "[y1, x1, y2, x2]": [925, 142, 938, 465],
      "text": "220 | Chương 9: Xác thực và Đo lường"
    }
  ],
  "page_3": [
    {
      "[y1, x1, y2, x2]": [90, 142, 172, 856],
      "text": "Điều quan trọng không kém là thiết lập một quy trình đáng tin cậy để tung ra các phiên bản mới, giám sát sự suy giảm sau khi ra mắt và cho phép quay lui nhanh chóng nếu có vấn đề không mong muốn phát sinh. Đây là nơi nền tảng của việc đánh giá ngoại tuyến, mạnh mẽ phát huy tác dụng, mang lại sự tự tin rằng hệ thống được triển khai sẽ hoạt động như mong đợi đồng thời giảm thiểu rủi ro cho người dùng và doanh nghiệp."
    },
    {
      "[y1, x1, y2, x2]": [188, 142, 241, 856],
      "text": "Bằng cách chuẩn bị kỹ lưỡng cho việc triển khai và thiết lập các cổng chất lượng rõ ràng, các nhóm tạo ra một văn hóa trách nhiệm và xuất sắc, đảm bảo rằng chỉ những hệ thống tác tử đáp ứng các tiêu chuẩn cao nhất mới đến tay người dùng."
    },
    {
      "[y1, x1, y2, x2]": [264, 142, 283, 281],
      "text": "Kết luận"
    },
    {
      "[y1, x1, y2, x2]": [300, 142, 424, 856],
      "text": "Đo lường và xác thực tạo thành xương sống của việc phát triển các hệ thống dựa trên tác tử mạnh mẽ và đáng tin cậy, đảm bảo chúng sẵn sàng hoạt động hiệu quả trong các kịch bản thực tế. Bằng cách xác định các mục tiêu rõ ràng và lựa chọn các chỉ số phù hợp, các nhà phát triển tạo ra một nền tảng có cấu trúc để đánh giá hiệu suất của một tác tử. Phân tích lỗi kỹ lưỡng giúp phát hiện các điểm yếu và thông báo các cải tiến có mục tiêu, trong khi các đánh giá đa tầng cung cấp một cái nhìn toàn diện về khả năng của hệ thống, từ các thành phần riêng lẻ đến các tương tác người dùng quy mô lớn."
    },
    {
      "[y1, x1, y2, x2]": [440, 142, 564, 856],
      "text": "Như được minh họa qua ví dụ đang chạy của chúng tôi về tác tử hỗ trợ khách hàng thương mại điện tử—xử lý mọi thứ từ việc hoàn tiền cho một chiếc cốc bị nứt đơn giản (order_id A89268) đến các yêu cầu hủy và sửa đổi phức tạp—các phương pháp đo lường và xác thực này đảm bảo hiệu suất mạnh mẽ trên các kịch bản đa dạng. Bằng cách lặp đi lặp lại việc tinh chỉnh các chỉ số và bộ đánh giá dựa trên các trường hợp phân luồng như vậy, các nhóm có thể triển khai các tác tử không chỉ đáp ứng mục tiêu mà còn thích ứng với nhu cầu người dùng đang thay đổi, cuối cùng là nuôi dưỡng sự tin tưởng và hiệu quả trong các ứng dụng thực tế."
    },
    {
      "[y1, x1, y2, x2]": [580, 142, 687, 856],
      "text": "Cách tiếp cận phân lớp và có phương pháp này đảm bảo rằng các hệ thống dựa trên tác tử đạt được các mục tiêu hiệu suất của chúng, mang lại trải nghiệm người dùng liền mạch và thỏa mãn, và duy trì độ tin cậy ngay cả trong các môi trường năng động và phức tạp. Các bài kiểm thử đơn vị và tích hợp toàn diện bảo vệ tính toàn vẹn của các chức năng cốt lõi và hành vi toàn hệ thống, cho phép các nhà phát triển giải quyết các vấn đề tiềm ẩn trước khi triển khai."
    },
    {
      "[y1, x1, y2, x2]": [703, 142, 793, 856],
      "text": "Cuối cùng, việc đo lường và xác thực cẩn thận trao quyền cho các nhóm triển khai các hệ thống tác tử một cách tự tin, biết rằng chúng có thể chịu được những thách thức của hoạt động thực tế trong khi đáp ứng nhu cầu của người dùng. Bằng cách ưu tiên các phương pháp này, các nhà phát triển không chỉ nâng cao chất lượng và độ tin cậy của hệ thống của họ, mà còn mở đường cho những đóng góp có ý nghĩa cho các ứng dụng dự kiến của chúng trên các ngành công nghiệp và các trường hợp sử dụng khác nhau."
    },
    {
      "[y1, x1, y2, x2]": [925, 733, 938, 856],
      "text": "Kết luận | 221"
    }
  ],
  "page_4": [],
  "page_5": [
    {
      "[y1, x1, y2, x2]": [121, 743, 134, 856],
      "text": "CHƯƠNG 10"
    },
    {
      "[y1, x1, y2, x2]": [157, 442, 182, 856],
      "text": "Giám sát trong Môi trường Sản xuất"
    },
    {
      "[y1, x1, y2, x2]": [247, 142, 371, 856],
      "text": "Dù bạn là chủ sở hữu sản phẩm, kỹ sư học máy (ML), hay kỹ sư độ tin cậy trang web (SRE), một khi các tác tử đi vào sản xuất, bạn cần phải thấy chúng đang làm gì và tại sao. Việc đưa các hệ thống tác tử ra thị trường chỉ là nửa chặng đường. Thách thức thực sự bắt đầu khi các tác tử của bạn hoạt động trong các môi trường năng động, không thể đoán trước và có rủi ro cao. Giám sát là cách bạn học hỏi từ thực tế—cách bạn phát hiện lỗi trước khi chúng leo thang, xác định sự suy giảm trước khi người dùng nhận thấy, và điều chỉnh hệ thống để phản ứng với các tín hiệu từ thế giới thực."
    },
    {
      "[y1, x1, y2, x2]": [387, 142, 477, 856],
      "text": "Không giống như phần mềm truyền thống, các tác tử hoạt động theo xác suất. Chúng phụ thuộc vào các mô hình nền tảng, kết nối các công cụ lại với nhau và phản ứng với các đầu vào không giới hạn của người dùng. Bạn không thể viết các bài kiểm thử toàn diện cho mọi kịch bản. Đó là lý do tại sao giám sát trở thành hệ thần kinh của cơ sở hạ tầng tác tử được triển khai của bạn."
    },
    {
      "[y1, x1, y2, x2]": [493, 142, 546, 856],
      "text": "Giám sát không chỉ là việc phát hiện vấn đề. Đó là xương sống của một vòng lặp phản hồi chặt chẽ giúp tăng tốc quá trình học hỏi và lặp lại. Các nhóm giám sát tốt sẽ học hỏi nhanh hơn, giao hàng an toàn hơn và cải thiện độ tin cậy với mỗi lần triển khai."
    },
    {
      "[y1, x1, y2, x2]": [562, 142, 633, 856],
      "text": "Trong chương này, chúng tôi tập trung vào giám sát mã nguồn mở. Mặc dù có những nền tảng thương mại xuất sắc như Arize AX, Langfuse và WhyLabs, chúng tôi sẽ tập trung ở đây vào các công cụ bạn có thể tự lưu trữ và mở rộng một cách tự do. Bộ công cụ tham khảo của chúng tôi bao gồm:"
    },
    {
      "[y1, x1, y2, x2]": [649, 142, 680, 467],
      "text": "OpenTelemetry\nĐể đo lường các luồng công việc của tác tử"
    },
    {
      "[y1, x1, y2, x2]": [781, 142, 812, 437],
      "text": "Loki\nĐể tổng hợp và tìm kiếm nhật ký"
    },
    {
      "[y1, x1, y2, x2]": [925, 834, 938, 856],
      "text": "223"
    }
  ],
  "page_6": [
    {
      "[y1, x1, y2, x2]": [83, 142, 114, 342],
      "text": "Tempo\nCho các dấu vết phân tán"
    },
    {
      "[y1, x1, y2, x2]": [130, 142, 161, 477],
      "text": "Grafana\nĐể trực quan hóa, cảnh báo và bảng điều khiển"
    },
    {
      "[y1, x1, y2, x2]": [177, 142, 230, 856],
      "text": "Chúng tôi sẽ hướng dẫn cách tích hợp từng công cụ này với một hệ thống tác tử dựa trên LangGraph, sau đó chỉ ra cách các mảnh ghép lại với nhau trong một vòng lặp phản hồi để thu hẹp khoảng cách giữa quan sát và cải tiến."
    },
    {
      "[y1, x1, y2, x2]": [261, 142, 280, 521],
      "text": "Giám sát là cách bạn học hỏi"
    },
    {
      "[y1, x1, y2, x2]": [297, 142, 370, 856],
      "text": "Hiểu rõ nguyên nhân gốc rễ của các lỗi tác tử—từ lỗi phần mềm và các biến thể của mô hình nền tảng đến các giới hạn kiến trúc—là điều cần thiết để bảo trì chủ động và khả năng thích ứng của hệ thống. Mỗi loại lỗi đòi hỏi các phương pháp phát hiện, phân tích và khắc phục có mục tiêu để duy trì sự ổn định trong sản xuất."
    },
    {
      "[y1, x1, y2, x2]": [386, 142, 454, 856],
      "text": "Các hệ thống tác tử tốt nhất cải thiện theo thời gian thông qua phản hồi. Giám sát truyền thống phản ứng với các sự cố hoặc sụt giảm thông lượng, nhưng đối với các tác tử, nó là nền tảng: tiết lộ các vấn đề mới nổi trong các hành vi xác suất và hướng dẫn phát triển trong bối cảnh không chắc chắn."
    },
    {
      "[y1, x1, y2, x2]": [470, 142, 546, 856],
      "text": "Các lỗi của tác tử rất tinh vi—một công cụ thành công nhưng gây ra lỗi dây chuyền, một đầu ra của LLM nghe có vẻ trôi chảy nhưng lại gây hiểu lầm, hoặc một kế hoạch hoạt động một phần nhưng không đạt được mục tiêu. Những sự không khớp này hiếm khi làm hệ thống bị treo; việc giám sát phải nhanh chóng phơi bày chúng, làm cho khả năng quan sát trong sản xuất trở nên không thể thiếu."
    },
    {
      "[y1, x1, y2, x2]": [562, 142, 687, 856],
      "text": "Lỗi không chỉ là sự cố—chúng là các trường hợp kiểm thử. Mỗi khi một tác tử gặp sự cố trong sản xuất, kịch bản đó nên được ghi lại và biến thành một bài kiểm thử hồi quy. Nhưng điều tương tự cũng đúng với thành công: khi một tác tử xử lý tốt một trường hợp phức tạp, dấu vết đó có thể trở thành một con đường vàng đáng để bảo tồn. Bằng cách xuất cả dấu vết lỗi và các ví dụ thành công vào bộ kiểm thử của bạn, bạn tạo ra một kho CI/CD sống động phản ánh các điều kiện thực tế. Thực hành này giúp “dịch chuyển sang trái” chiến lược giám sát của bạn—phát hiện các vấn đề sớm hơn trong quá trình phát triển và đảm bảo rằng các phiên bản tác tử mới được xác thực liên tục dựa trên sự phức tạp thực tế của hành vi sản xuất."
    },
    {
      "[y1, x1, y2, x2]": [703, 142, 885, 856],
      "text": "Một thách thức chính trong việc giám sát các hệ thống xác suất như các tác tử là phân biệt giữa các “lỗi” thực sự (các vấn đề hệ thống cần sửa chữa) và các biến thể dự kiến (tính không xác định cố hữu nơi đầu ra khác nhau nhưng vẫn chấp nhận được). Một cây quyết định đơn giản có thể hướng dẫn điều này. Bắt đầu với đầu ra—nó có đáp ứng tiêu chí thành công không (ví dụ: điểm đánh giá > 0.8)? Nếu có, hãy theo dõi xu hướng nhưng không cần hành động. Nếu không, hãy kiểm tra khả năng tái tạo (chạy lại 3-5 lần; tỷ lệ thất bại > 80% cho thấy lỗi hệ thống cần xem xét kỹ thuật). Nếu không thể tái tạo, hãy đánh giá độ tin cậy/phương sai (ví dụ: điểm LLM > 0.7, phân kỳ Kullback-Leibler < 0.2 so với đường cơ sở). Nằm trong giới hạn có nghĩa là biến thể dự kiến (ghi nhật ký để theo dõi sự trôi dạt), và nằm ngoài giới hạn cho thấy lỗi bất thường (ví dụ: sự trôi dạt đầu vào thông qua chỉ số ổn định dân số > 0.1, kích hoạt các biện pháp giảm thiểu như đào tạo lại hoặc các hàng rào bảo vệ)."
    },
    {
      "[y1, x1, y2, x2]": [925, 142, 938, 465],
      "text": "224 | Chương 10: Giám sát trong Môi trường Sản xuất"
    }
  ],
  "page_7": [
    {
      "[y1, x1, y2, x2]": [90, 142, 125, 856],
      "text": "Lưu đồ này, được áp dụng trong các công cụ như Grafana, ngăn chặn phản ứng thái quá với nhiễu trong khi vẫn nắm bắt được các sự suy giảm thực sự sớm."
    },
    {
      "[y1, x1, y2, x2]": [141, 142, 248, 856],
      "text": "Giám sát hiệu quả bao gồm các tín hiệu cơ sở hạ tầng (độ trễ, tỷ lệ lỗi, CPU) và các hành vi ngữ nghĩa (nắm bắt ý định, lựa chọn công cụ, ảo giác, từ bỏ nhiệm vụ). Ý định của người dùng có được hiểu không? Công cụ phù hợp có được chọn không? Hệ thống có tạo ra nội dung ảo giác không? Người dùng có từ bỏ nhiệm vụ giữa chừng không? Đây không phải là những câu hỏi mà các hệ thống giám sát truyền thống được xây dựng để trả lời, nhưng chúng rất quan trọng để đảm bảo các tác tử vẫn đáng tin cậy, hữu ích và phù hợp."
    },
    {
      "[y1, x1, y2, x2]": [264, 142, 335, 856],
      "text": "Xây dựng một vòng lặp phản hồi phân lớp: đo lường các sự kiện thời gian chạy (lệnh gọi công cụ, tạo ra, dự phòng) với ngữ cảnh, truyền trực tuyến đến các backend như Loki (nhật ký), Tempo (dấu vết) và Grafana (trực quan hóa/cảnh báo). Thêm các tín hiệu đánh giá—điểm số ảo giác hoặc chỉ số trôi dạt—thông qua các trình phê bình bên ngoài trong thời gian thực."
    },
    {
      "[y1, x1, y2, x2]": [351, 142, 458, 856],
      "text": "Điều đáng nhấn mạnh là tất cả những điều này có thể—và nên—là một phần của cùng một đường ống quan sát được sử dụng cho các dịch vụ sản xuất. Cùng một phiên bản Prometheus theo dõi sức khỏe dịch vụ cũng có thể theo dõi tỷ lệ thành công của tác tử. Cùng một bảng điều khiển Grafana được SRE sử dụng có thể bao gồm tỷ lệ lỗi ngữ nghĩa, phân phối độ trễ của mô hình và biểu đồ sử dụng công cụ. Không cần một bộ công cụ giám sát riêng biệt; các tác tử được hưởng lợi từ sự nghiêm ngặt và khả năng hiển thị tương tự như bất kỳ dịch vụ quan trọng nào khác."
    },
    {
      "[y1, x1, y2, x2]": [474, 142, 633, 856],
      "text": "Tất nhiên, dữ liệu quan sát thường chứa nội dung nhạy cảm. Nhật ký có thể bao gồm tin nhắn của người dùng, đầu vào công cụ hoặc các thế hệ LLM trung gian. Để duy trì sự tuân thủ và quyền riêng tư của người dùng, các nhóm nên cấu hình các cụm giám sát riêng biệt với kiểm soát truy cập dựa trên vai trò (RBAC) nghiêm ngặt. Dữ liệu nhạy cảm có thể được định tuyến đến các backend bị cô lập với mã hóa khi lưu trữ và kiểm tra truy cập, đảm bảo rằng việc gỡ lỗi và phân tích hiệu suất vẫn có thể thực hiện được mà không ảnh hưởng đến sự tin tưởng hoặc các nghĩa vụ tuân thủ. Việc biên tập, băm hoặc che giấu thông tin nhận dạng cá nhân (PII) khỏi nhật ký quan sát trước khi xuất cũng là một thực hành phổ biến. OpenTelemetry cung cấp các hook để làm sạch dữ liệu trong quá trình xuất span, cho phép kiểm soát chi tiết về những gì rời khỏi ranh giới của ứng dụng."
    },
    {
      "[y1, x1, y2, x2]": [649, 142, 702, 856],
      "text": "Cuối cùng, giám sát biến các chỉ số thành hành động—giúp các nhóm phát hiện những gì quan trọng và phản ứng nhanh chóng. Các phần sau đây cho thấy cách các công cụ mã nguồn mở xây dựng vòng lặp này, đẩy nhanh quá trình phát triển, tính mạnh mẽ và độ tin cậy trong các môi trường trực tiếp."
    },
    {
      "[y1, x1, y2, x2]": [718, 142, 771, 856],
      "text": "Trước khi đi sâu vào chi tiết về việc đo lường, việc xác định những gì bạn thực sự muốn quan sát là rất hữu ích. Giám sát hiệu quả bắt đầu bằng việc chọn đúng các chỉ số—những chỉ số không chỉ tiết lộ liệu hệ thống có đang hoạt động hay không, mà còn liệu nó có đang hoạt động như dự kiến hay không."
    },
    {
      "[y1, x1, y2, x2]": [787, 142, 823, 856],
      "text": "Bảng 10-1 là một phân loại thực tế của các chỉ số, được tổ chức theo lớp trừu tượng, có thể hướng dẫn những gì cần thu thập, trực quan hóa và cảnh báo."
    },
    {
      "[y1, x1, y2, x2]": [925, 631, 938, 856],
      "text": "Giám sát là cách bạn học hỏi | 225"
    }
  ],
  "page_8": [
    {
      "[y1, x1, y2, x2]": [83, 142, 699, 856],
      "table": [
        [
          "",
          "Chỉ số",
          "Mục đích",
          "Hành động ví dụ"
        ],
        [
          "Hạ tầng",
          "Sử dụng CPU/bộ nhớ",
          "Giám sát sức khỏe hệ thống và áp lực mở rộng",
          "Tự động co giãn hoặc tối ưu hóa các công cụ sử dụng nhiều bộ nhớ"
        ],
        [
          "",
          "Thời gian hoạt động/khả dụng",
          "Theo dõi tính khả dụng của dịch vụ và phục hồi sau sự cố",
          "Kích hoạt phản ứng sự cố"
        ],
        [
          "",
          "Độ trễ yêu cầu (P50,\nP95, P99)",
          "Đảm bảo khả năng phản hồi dưới tải",
          "Tham gia vào việc điều chỉnh bộ nhớ đệm hoặc logic thử lại"
        ],
        [
          "Cấp độ luồng công việc",
          "Tỷ lệ thành công của tác vụ",
          "Xác định tần suất các tác tử hoàn thành các luồng công việc dự kiến",
          "Điều tra các lỗi hoặc cập nhật các câu lệnh"
        ],
        [
          "",
          "Sử dụng token",
          "Đo lường mức tiêu thụ token ở cấp độ luồng công việc",
          "Sự tăng hoặc giảm nhanh chóng có thể chỉ ra các vấn đề"
        ],
        [
          "",
          "Tỷ lệ thành công/thất bại của lệnh gọi công cụ",
          "Phát hiện các tích hợp bị suy giảm hoặc sử dụng sai công cụ",
          "Vá các trình bao bọc hoặc tự động quay lại phương án dự phòng"
        ],
        [
          "",
          "Vượt quá giới hạn tỷ lệ sử dụng công cụ",
          "Theo dõi các trường hợp lệnh gọi công cụ của tác tử vượt quá giới hạn đã xác định trước trong các khoảng thời gian cụ thể",
          "Điều chỉnh giới hạn hoặc điều chỉnh tần suất gọi"
        ],
        [
          "",
          "Tần suất thử lại",
          "Xác định sự không ổn định hoặc thiếu tin cậy trong các kế hoạch hoặc công cụ",
          "Chống dội các lần thử lại hoặc tinh chỉnh logic lập kế hoạch"
        ],
        [
          "",
          "Tần suất dự phòng",
          "Làm nổi bật các lỗi trong các luồng công việc chính",
          "Cải thiện độ bền vững hoặc leo thang cho con người"
        ],
        [
          "Chất lượng đầu ra",
          "Sử dụng token (đầu vào/\nđầu ra)",
          "Theo dõi độ dài dòng, chi phí và hiệu quả tạo ra",
          "Cắt bớt các câu lệnh dài hoặc chuyển đổi cấp độ mô hình"
        ],
        [
          "",
          "Chỉ báo ảo giác",
          "Đo lường độ chính xác ngữ nghĩa của nội dung được tạo ra",
          "Giới thiệu các bước nền tảng hoặc phê bình của LLM"
        ],
        [
          "",
          "Độ lệch embedding so với\nđường cơ sở",
          "Phát hiện sự thay đổi phân phối trong đầu vào của người dùng hoặc khung tác vụ",
          "Điều chỉnh các luồng công việc hoặc tinh chỉnh mô hình"
        ],
        [
          "Phản hồi người dùng",
          "Tỷ lệ truy vấn lại/diễn đạt lại",
          "Đo lường liệu người dùng có được hiểu ngay từ lần thử đầu tiên không",
          "Cải thiện phân loại ý định"
        ],
        [
          "",
          "Tỷ lệ từ bỏ tác vụ",
          "Xác định các luồng công việc gây nhầm lẫn hoặc làm nản lòng người dùng",
          "Đơn giản hóa các luồng hoặc thêm các câu lệnh làm rõ"
        ],
        [
          "",
          "Đánh giá rõ ràng (thích/\nkhông thích)",
          "Thu thập các đánh giá định tính về sự hữu ích của hệ thống",
          "Sử dụng nó để phân loại các đầu ra để đánh giá"
        ]
      ]
    },
    {
      "[y1, x1, y2, x2]": [709, 142, 799, 856],
      "text": "Mỗi chỉ số này có thể được ghi lại thông qua OpenTelemetry, tổng hợp trong Prometheus hoặc Loki, trực quan hóa trong Grafana và (khi thích hợp) liên kết với các dấu vết trong Tempo. Mục tiêu không phải là thu thập mọi thứ, mà là thu thập những gì cần thiết để phát hiện sự thay đổi có ý nghĩa—và làm điều đó theo cách hỗ trợ chẩn đoán nhanh chóng và cải tiến liên tục."
    },
    {
      "[y1, x1, y2, x2]": [830, 142, 849, 396],
      "text": "Các Bộ công cụ Giám sát"
    },
    {
      "[y1, x1, y2, x2]": [866, 142, 919, 856],
      "text": "Việc lựa chọn công cụ giám sát phù hợp là một quyết định quan trọng có thể đẩy nhanh hoặc cản trở tốc độ phát triển hệ thống tác tử của bạn. Khả năng quan sát phải nắm bắt được"
    },
    {
      "[y1, x1, y2, x2]": [925, 142, 938, 465],
      "text": "226 | Chương 10: Giám sát trong Môi trường Sản xuất"
    }
  ],
  "page_9": [
    {
      "[y1, x1, y2, x2]": [90, 142, 312, 856],
      "text": "không chỉ các chỉ số cơ sở hạ tầng truyền thống (ví dụ: độ trễ, thời gian hoạt động) mà còn cả những hiểu biết ngữ nghĩa như tỷ lệ ảo giác, hiệu quả của công cụ và sự thay đổi phân phối trong đầu vào của người dùng. Bối cảnh hiện tại nhấn mạnh các công cụ mã nguồn mở tích hợp liền mạch với các khung công tác như LangGraph, CrewAI và AutoGen, hỗ trợ truy vết phân tán, ghi nhật ký và cảnh báo trong khi xử lý bản chất xác suất của các mô hình nền tảng. Nhiều công ty đã có các kế hoạch doanh nghiệp cho các bộ công cụ ghi nhật ký được quản lý (ví dụ: Splunk, Datadog hoặc New Relic), và các mô hình nền tảng hoặc tác tử không nhất thiết phải yêu cầu một giải pháp giám sát hoàn toàn mới. Trong hầu hết các trường hợp, việc mở rộng bộ công cụ hiện có của bạn là khôn ngoan—tận dụng sự quen thuộc, khả năng mở rộng và tích hợp của nó—trừ khi bạn có nhu cầu mạnh mẽ về các tính năng chuyên biệt như đánh giá gốc cho các mô hình nền tảng hoặc tự lưu trữ nhẹ. Chúng tôi sẽ khám phá một số tùy chọn mã nguồn mở tương đương trong các tiểu mục sau, nêu bật các tính năng, tích hợp và sự đánh đổi để giúp bạn lựa chọn hoặc điều chỉnh dựa trên môi trường của mình."
    },
    {
      "[y1, x1, y2, x2]": [328, 142, 347, 722],
      "text": "Grafana với OpenTelemetry, Loki và Tempo"
    },
    {
      "[y1, x1, y2, x2]": [364, 142, 396, 856],
      "text": "Bộ công cụ này cung cấp khả năng kết hợp cao, làm cho nó trở thành một lựa chọn linh hoạt cho các nhóm xây dựng khả năng quan sát tùy chỉnh xung quanh các tác tử:"
    },
    {
      "[y1, x1, y2, x2]": [427, 142, 575, 856],
      "text": "Thiết lập và tích hợp\nKhởi tạo OpenTelemetry (OTel) trong ứng dụng LangGraph của bạn để xuất các span (ví dụ: cho các lệnh gọi công cụ hoặc các thế hệ LLM) và các chỉ số (ví dụ: việc sử dụng token). Các nhật ký được định tuyến đến Loki để truy vấn có cấu trúc, trong khi các dấu vết đi đến Tempo để có khả năng hiển thị từ đầu đến cuối. Grafana lấy dữ liệu từ cả hai, thiết lập các bảng điều khiển tương quan hành vi của tác tử (ví dụ: độ trễ lập kế hoạch) với sức khỏe hệ thống. Ví dụ: bọc một nút LangGraph bằng các span OTel để theo dõi các chỉ số tool_recall, xuất sang Tempo để truy vấn các phiên bị lỗi."
    },
    {
      "[y1, x1, y2, x2]": [591, 142, 672, 856],
      "text": "Các tính năng chính\nCác tính năng chính là các bảng điều khiển thời gian thực cho các chỉ số ngữ nghĩa (ví dụ: điểm số ảo giác thông qua các plug-in tùy chỉnh); cảnh báo về các bất thường như các đợt thử lại tăng đột biến; và cộng đồng mạnh mẽ cho các tiện ích mở rộng AI (ví dụ: các plug-in Grafana năm 2025 để phát hiện sự trôi dạt của LLM). Nó có khả năng mở rộng cho sản xuất, với chi phí thấp khi tự lưu trữ."
    },
    {
      "[y1, x1, y2, x2]": [688, 142, 752, 856],
      "text": "Sự đánh đổi\nƯu điểm bao gồm tính linh hoạt (trộn và kết hợp các thành phần) và không bị khóa nhà cung cấp; nhược điểm là thiết lập nhiều công cụ (yêu cầu quản lý Loki/Tempo riêng biệt) và đường cong học tập dốc hơn cho các nhóm không chuyên về hạ tầng. Điều này lý tưởng cho các doanh nghiệp mở rộng giám sát hạ tầng hiện có cho các tác tử."
    },
    {
      "[y1, x1, y2, x2]": [768, 142, 787, 731],
      "text": "Bộ công cụ ELK (Elasticsearch, Logstash/Fluentd, Kibana)"
    },
    {
      "[y1, x1, y2, x2]": [804, 142, 852, 856],
      "text": "Bộ công cụ ELK là một lựa chọn trưởng thành nhấn mạnh vào khả năng tìm kiếm và phân tích mạnh mẽ, thường được mở rộng từ các thiết lập doanh nghiệp hiện có cho các khối lượng công việc AI:"
    },
    {
      "[y1, x1, y2, x2]": [925, 687, 938, 856],
      "text": "Các Bộ công cụ Giám sát | 227"
    }
  ],
  "page_10": [
    {
      "[y1, x1, y2, x2]": [83, 179, 212, 856],
      "text": "Thiết lập và tích hợp\nSử dụng các bộ thu OTel để gửi dấu vết/nhật ký của tác tử đến Elasticsearch (thông qua Logstash để nhập liệu). Kibana cung cấp giao diện người dùng để truy vấn và tạo bảng điều khiển. Đối với LangGraph, hãy đo lường các nút để ghi lại các sự kiện có cấu trúc (ví dụ: JSON với các tham số công cụ), tận dụng các công việc ML của Elasticsearch để phát hiện bất thường trên đầu ra của tác tử. Ví dụ: truy vấn \"các sự kiện ảo giác trong đó độ tin cậy < 0.7\" trên các phiên, tương quan với phản hồi của người dùng."
    },
    {
      "[y1, x1, y2, x2]": [228, 179, 276, 856],
      "text": "Các tính năng chính\nCác tính năng chính bao gồm tìm kiếm văn bản đầy đủ và vector nâng cao cho các đầu ra của LLM (ví dụ: phát hiện trôi dạt dựa trên embedding); ML tích hợp cho các cảnh báo dự đoán (ví dụ: dự báo tỷ lệ lỗi công cụ); và khả năng mở rộng cho khối lượng nhật ký khổng lồ với phân cụm."
    },
    {
      "[y1, x1, y2, x2]": [292, 179, 421, 856],
      "text": "Sự đánh đổi\nƯu điểm là khả năng tìm kiếm và phân tích vượt trội (ví dụ: khớp mờ trên các câu lệnh, tốt hơn cho các lỗi đuôi dài) và khả năng mở rộng cấp doanh nghiệp. Nhược điểm là yêu cầu tài nguyên cao hơn (Elasticsearch tốn nhiều bộ nhớ) và việc triển khai phức tạp hơn (nhiều dịch vụ). Nó phù hợp nhất cho các nhóm đã có đầu tư vào ELK, mở rộng nó cho việc ghi nhật ký ngữ nghĩa cụ thể của tác tử mà không cần bắt đầu từ đầu."
    },
    {
      "[y1, x1, y2, x2]": [444, 142, 463, 311],
      "text": "Arize Phoenix"
    },
    {
      "[y1, x1, y2, x2]": [480, 142, 528, 856],
      "text": "Phoenix tập trung vào việc truy vết và đánh giá LLM, cung cấp một tiện ích mở rộng hướng đến việc gỡ lỗi để giám sát tác tử trong các môi trường hiện có:"
    },
    {
      "[y1, x1, y2, x2]": [559, 179, 612, 856],
      "text": "Thiết lập và tích hợp\nSử dụng SDK Python của Phoenix để đo lường LangGraph (ví dụ: truy vết các lệnh gọi LLM với các đánh giá). Nó hỗ trợ xuất OTel để sử dụng kết hợp. Ví dụ: trực quan hóa các dấu vết của tác tử với các trình chấm điểm tự động về độ chính xác, xuất ra các notebook để phân tích."
    },
    {
      "[y1, x1, y2, x2]": [628, 179, 681, 856],
      "text": "Các tính năng chính\nCác tính năng chính bao gồm truy vết có cấu trúc với các đánh giá (ví dụ: chất lượng RAG, phát hiện ảo giác); tích hợp Jupyter cho các luồng công việc ML; và các cải tiến năm 2025 cho các chỉ số điều phối đa tác tử."
    },
    {
      "[y1, x1, y2, x2]": [697, 179, 767, 856],
      "text": "Sự đánh đổi\nƯu điểm là nó chuyên biệt cho việc đánh giá/gỡ lỗi (hiểu biết nhanh hơn về chất lượng tác tử) và nhẹ cho việc tạo mẫu. Nhược điểm là nó bị giới hạn ở các dấu vết/đánh giá (bổ sung cho nhật ký/chỉ số đầy đủ) và hướng đến nhà phát triển hơn là vận hành. Nó rất tuyệt vời cho các nhóm nghiên cứu/ML thêm các hiểu biết về tác tử vào các bộ công cụ doanh nghiệp được quản lý."
    },
    {
      "[y1, x1, y2, x2]": [925, 142, 938, 465],
      "text": "228 | Chương 10: Giám sát trong Môi trường Sản xuất"
    }
  ],
  "page_11": [
    {
      "[y1, x1, y2, x2]": [83, 142, 102, 222],
      "text": "SigNoz"
    },
    {
      "[y1, x1, y2, x2]": [119, 142, 167, 856],
      "text": "SigNoz là một nền tảng thống nhất, gốc OTel, kết hợp các chỉ số, dấu vết và nhật ký trong một công cụ duy nhất, phù hợp cho các phần mở rộng hợp lý của các thiết lập giám sát cơ bản:"
    },
    {
      "[y1, x1, y2, x2]": [198, 179, 268, 856],
      "text": "Thiết lập và tích hợp\nSigNoz nhập dữ liệu OTel trực tiếp, với khả năng đo lường tự động cho Python (ví dụ: LangGraph). Thêm các span cho các bước của tác tử (ví dụ: độ trễ lập kế hoạch) và truy vấn thông qua giao diện người dùng của nó. Ví dụ: truy vết một luồng tác tử nhiều bước, lọc theo token_usage > 1000 để phát hiện sự kém hiệu quả, với các đánh giá tích hợp cho chất lượng LLM."
    },
    {
      "[y1, x1, y2, x2]": [284, 179, 337, 856],
      "text": "Các tính năng chính\nNó có các hiểu biết được hỗ trợ bởi AI tích hợp (ví dụ: phát hiện bất thường trên các dấu vết của tác tử); các bảng điều khiển tùy chỉnh cho các chỉ số LLM (ví dụ: trôi dạt câu lệnh); và tự lưu trữ nhẹ với backend ClickHouse để đạt hiệu quả."
    },
    {
      "[y1, x1, y2, x2]": [353, 179, 439, 856],
      "text": "Sự đánh đổi\nƯu điểm bao gồm thiết lập đơn giản hơn (một ứng dụng duy nhất), chi phí thấp hơn cho các nhóm nhỏ và hỗ trợ OTel mạnh mẽ với các tiện ích mở rộng AI (ví dụ: cập nhật năm 2025 cho việc tự động chấm điểm ảo giác). Nhược điểm là nó có một hệ sinh thái ít mở rộng hơn (ít plug-in hơn) và việc trực quan hóa có chức năng nhưng không quá nâng cao. Nó rất phù hợp cho các công ty khởi nghiệp hoặc các nhóm tập trung vào ML mở rộng giám sát nhẹ mà không cần thêm nhiều hạ tầng."
    },
    {
      "[y1, x1, y2, x2]": [462, 142, 481, 258],
      "text": "Langfuse"
    },
    {
      "[y1, x1, y2, x2]": [498, 142, 546, 856],
      "text": "Langfuse chuyên về khả năng quan sát mô hình nền tảng và tác tử, giúp dễ dàng mở rộng các bộ công cụ hiện có với việc truy vết tập trung vào ngữ nghĩa cho các tác tử:"
    },
    {
      "[y1, x1, y2, x2]": [577, 179, 647, 856],
      "text": "Thiết lập và tích hợp\nTích hợp thông qua SDK trong LangGraph (ví dụ: bọc các nút bằng các trình truy vết Langfuse). Nó ghi lại các câu lệnh, đầu ra và các đánh giá (ví dụ: các trình chấm điểm tùy chỉnh về sự mạch lạc). Ví dụ: ghi lại một phiên tác tử đầy đủ, tự động đánh giá ảo giác và xuất các dấu vết để kiểm thử hồi quy."
    },
    {
      "[y1, x1, y2, x2]": [663, 179, 716, 856],
      "text": "Các tính năng chính\nNó có các chỉ số gốc LLM (ví dụ: theo dõi chi phí token, kiểm thử A/B cho các câu lệnh); phát lại phiên để gỡ lỗi; và nó có thể tự lưu trữ với các backend cơ sở dữ liệu như PostgreSQL."
    },
    {
      "[y1, x1, y2, x2]": [732, 179, 818, 856],
      "text": "Sự đánh đổi\nƯu điểm là nó được thiết kế riêng cho các tác tử/LLM (vì các đánh giá tích hợp giúp tiết kiệm công việc tùy chỉnh) và dễ dàng cho các nhóm phát triển (tập trung vào các hiểu biết cấp ứng dụng). Nhược điểm là nó có phạm vi hẹp hơn (yếu hơn về các chỉ số hạ tầng như CPU; kết hợp với Prometheus) và nó ít có khả năng mở rộng hơn cho các đo lường không phải LLM. Nó lý tưởng cho việc mở rộng ghi nhật ký doanh nghiệp với các tính năng cụ thể của tác tử mà không cần đại tu bộ công cụ cốt lõi."
    },
    {
      "[y1, x1, y2, x2]": [925, 687, 938, 856],
      "text": "Các Bộ công cụ Giám sát | 229"
    }
  ],
  "page_12": [
    {
      "[y1, x1, y2, x2]": [83, 142, 102, 447],
      "text": "Chọn Bộ công cụ Phù hợp"
    },
    {
      "[y1, x1, y2, x2]": [119, 142, 259, 856],
      "text": "Tất cả các bộ công cụ mã nguồn mở này đều là những lựa chọn tương đương khả thi—hãy bắt đầu bằng cách đánh giá thiết lập hiện tại của bạn. Nếu bạn có một giải pháp do doanh nghiệp quản lý, hãy mở rộng nó với việc đo lường OTel cho các tín hiệu của tác tử trừ khi bạn cần các tính năng cụ thể của LLM như tự động đánh giá (ưu tiên Langfuse/Phoenix) hoặc tìm kiếm nâng cao (ELK). Đối với các dự án mới, Grafana hoặc SigNoz cung cấp phạm vi bao phủ rộng. Đánh giá dựa trên chuyên môn của nhóm, khối lượng dữ liệu và nhu cầu tích hợp—nhiều công cụ có thể kết hợp (ví dụ: OTel đến nhiều backend). Bảng 10-2 cho thấy những sự đánh đổi này một cách tổng quan."
    },
    {
      "[y1, x1, y2, x2]": [272, 142, 425, 818],
      "table": [
        [
          "Bộ công cụ",
          "Điểm mạnh chính",
          "Tốt nhất cho",
          "Đánh đổi (so với Grafana)"
        ],
        [
          "Grafana + Loki/Tempo",
          "Khả năng kết hợp và trực quan hóa",
          "Hoạt động doanh nghiệp",
          "Nhiều thành phần hơn để quản lý"
        ],
        [
          "Bộ công cụ ELK",
          "Tìm kiếm/phân tích nâng cao",
          "Nhật ký quy mô lớn",
          "Sử dụng tài nguyên cao hơn"
        ],
        [
          "Phoenix",
          "Truy vết và gỡ lỗi",
          "Vòng lặp phát triển",
          "Quy mô sản xuất hạn chế"
        ],
        [
          "SigNoz",
          "Thống nhất và nhẹ",
          "Các nhóm khởi nghiệp/ML",
          "Ít khả năng mở rộng hơn"
        ],
        [
          "Langfuse",
          "Đánh giá cụ thể cho mô hình nền tảng/tác tử",
          "Giám sát ngữ nghĩa",
          "Phạm vi bao phủ hạ tầng hẹp hơn"
        ]
      ]
    },
    {
      "[y1, x1, y2, x2]": [441, 142, 633, 856],
      "text": "Mặc dù bối cảnh khả năng quan sát cung cấp nhiều lựa chọn mạnh mẽ—mỗi lựa chọn có những điểm mạnh riêng về khả năng mở rộng, dễ sử dụng hoặc các tính năng cụ thể của LLM—sự cạnh tranh này thúc đẩy sự đổi mới và đảm bảo các nhóm có thể tìm thấy một giải pháp phù hợp với nhu cầu của họ, cho dù là mở rộng các bộ công cụ doanh nghiệp hay bắt đầu mới. Đối với các ví dụ của chúng tôi trong các phần sau, chúng tôi sẽ tập trung vào OTel với Grafana, Loki và Tempo, vì nó cung cấp một nền tảng mã nguồn mở, có khả năng kết hợp cao, được áp dụng rộng rãi và tích hợp liền mạch với các khung công tác tác tử như LangGraph, cho phép chúng tôi trình bày các khái niệm cốt lõi mà không bị khóa nhà cung cấp. Với một bộ công cụ đã được chọn, bước tiếp theo là đo lường—nhúng đo lường từ xa trực tiếp vào thời gian chạy của tác tử của bạn để thu thập các tín hiệu có ý nghĩa, như được khám phá trong phần tiếp theo."
    },
    {
      "[y1, x1, y2, x2]": [656, 142, 675, 430],
      "text": "Đo lường OTel"
    },
    {
      "[y1, x1, y2, x2]": [692, 142, 762, 856],
      "text": "Bước đầu tiên trong việc xây dựng một vòng lặp giám sát hiệu quả là đo lường. Nếu không có các tín hiệu chất lượng cao được nhúng trực tiếp vào thời gian chạy của tác tử, bạn sẽ như đang bay mù. OTel cung cấp nền tảng cho việc đo lường từ xa có cấu trúc, có thể tương tác trên các dấu vết, chỉ số và nhật ký—và nó tích hợp tốt với các hệ thống tác tử dựa trên LangGraph."
    },
    {
      "[y1, x1, y2, x2]": [778, 142, 885, 856],
      "text": "LangGraph được cấu trúc như một đồ thị của các lệnh gọi hàm không đồng bộ. Mỗi nút trong đồ thị đại diện cho một bước chức năng trong một luồng công việc của tác tử—có thể là lập kế hoạch, gọi một công cụ hoặc tạo ra một phản hồi với một LLM. Bởi vì mỗi bước đã được cô lập và khai báo rõ ràng, việc đo lường từng bước với các span OTel là rất đơn giản. Các span này tạo ra một dấu vết có cấu trúc ghi lại không chỉ thời điểm các bước bắt đầu và kết thúc, mà còn cả những gì chúng đang cố gắng làm và chúng đã thực hiện như thế nào."
    },
    {
      "[y1, x1, y2, x2]": [925, 142, 938, 465],
      "text": "230 | Chương 10: Giám sát trong Môi trường Sản xuất"
    }
  ],
  "page_13": [
    {
      "[y1, x1, y2, x2]": [90, 142, 172, 856],
      "text": "Đối với mỗi nút, chúng tôi khuyên bạn nên bắt đầu một span ở đầu hàm và chú thích nó với siêu dữ liệu liên quan. Ví dụ, trong một nút gọi công cụ, bạn có thể ghi lại tên công cụ, phương thức cụ thể được gọi, độ trễ của phản hồi, trạng thái thành công hay thất bại và bất kỳ mã lỗi nào đã biết. Trong các nút nơi LLM tạo ra đầu ra, span có thể bao gồm các định danh câu lệnh, số lượng token, độ trễ của mô hình và các cờ cho nguy cơ ảo giác hoặc điểm tin cậy."
    },
    {
      "[y1, x1, y2, x2]": [188, 142, 278, 856],
      "text": "Việc đo lường này không yêu cầu những thay đổi kiến trúc lớn. SDK Python của OTel có thể được khởi tạo một lần khi khởi động, và các span có thể được tạo và đóng bằng cách sử dụng các trình quản lý ngữ cảnh đơn giản. Ngữ cảnh truy vết phân tán được tự động lan truyền qua các lệnh gọi không đồng bộ, giúp dễ dàng tương quan hành vi từ đầu đến cuối ngay cả trong các luồng tác tử phức tạp, có nhiều nhánh. Dưới đây là một ví dụ đơn giản về cách bọc một nút LangGraph bằng một span truy vết:"
    },
    {
      "[y1, x1, y2, x2]": [301, 179, 483, 706],
      "code": "from opentelemetry import trace\ntracer = trace.get_tracer(\"agent\")\n\nasync def call_tool_node(context):\n    with tracer.start_as_current_span(\"call_tool\", attributes={\n        \"tool\": context.tool_name,\n        \"input_tokens\": context.token_usage.input,\n        \"output_tokens\": context.token_usage.output,\n    }):\n        result = await call_tool(context)\n        return result"
    },
    {
      "[y1, x1, y2, x2]": [526, 142, 579, 856],
      "text": "Các span có thể bao gồm các sự kiện (như các trình kích hoạt dự phòng hoặc thử lại), các subspan lồng nhau (để đo lường các lệnh gọi API hạ nguồn) và việc ghi lại ngoại lệ để tự động gắn thẻ lỗi. Các dấu vết này được xuất trong thời gian thực đến các backend như Tempo hoặc Jaeger và được trực quan hóa cùng với nhật ký và chỉ số trong Grafana."
    },
    {
      "[y1, x1, y2, x2]": [595, 142, 666, 856],
      "text": "Ngoài các dấu vết, OTel có thể phát ra các nhật ký có cấu trúc và các chỉ số thời gian chạy. Ví dụ, bạn có thể ghi lại số lần một công cụ cụ thể được gọi, thời gian phản hồi trung bình cho mỗi nút lập kế hoạch, hoặc tỷ lệ phần trăm các tác vụ thất bại cho mỗi phiên bản mô hình. Các chỉ số này là vô giá để tạo các bảng điều khiển và cảnh báo theo dõi hiệu suất dài hạn và phát hiện các dấu hiệu suy giảm sớm."
    },
    {
      "[y1, x1, y2, x2]": [682, 142, 771, 856],
      "text": "Việc đo lường phải được xác định phạm vi một cách cẩn thận. Quá nhiều chi tiết sẽ trở nên nhiễu; quá ít sẽ làm cho việc phân tích nguyên nhân gốc rễ trở nên khó khăn. Chìa khóa là đính kèm vừa đủ ngữ cảnh ở mỗi bước—ID yêu cầu của người dùng, siêu dữ liệu phiên, trạng thái cấu hình tác tử, tên kỹ năng và các tín hiệu đánh giá—để khi có sự cố xảy ra, dấu vết bằng chứng sẽ mạch lạc, đầy đủ và dễ dàng tìm kiếm."
    },
    {
      "[y1, x1, y2, x2]": [787, 142, 858, 856],
      "text": "Tempo hoạt động như backend truy vết. Mỗi span bạn đo lường trong LangGraph—mỗi lệnh gọi công cụ, tạo kế hoạch hoặc dự phòng—là một phần của một dấu vết phân tán. Tempo lưu trữ các dấu vết này một cách có khả năng mở rộng cao và hỗ trợ truy vấn sâu. Ví dụ, bạn có thể lọc tất cả các dấu vết trong đó bước lập kế hoạch mất hơn 1.5 giây, hoặc"
    },
    {
      "[y1, x1, y2, x2]": [925, 663, 938, 856],
      "text": "Đo lường OTel | 231"
    }
  ],
  "page_14": [
    {
      "[y1, x1, y2, x2]": [90, 142, 140, 856],
      "text": "trong đó một lệnh gọi công cụ cụ thể đã thất bại với một mã lỗi nhất định. Điều này cho phép gỡ lỗi chính xác các vấn đề tinh vi chỉ xuất hiện trong các điều kiện thực thi nhiều bước, trong thế giới thực."
    },
    {
      "[y1, x1, y2, x2]": [156, 142, 297, 856],
      "text": "Loki, ngược lại, phục vụ như lớp tổng hợp nhật ký của bạn. Nó ghi lại các nhật ký có cấu trúc—thường ở định dạng JSON—từ khắp cơ sở hạ tầng tác tử của bạn. Mỗi nút LangGraph có thể phát ra các sự kiện nhật ký có cấu trúc trong quá trình thực thi của nó: khi một truy vấn của người dùng được nhận, khi một công cụ được gọi, khi một LLM tạo ra một phản hồi không rõ ràng, hoặc khi một đường dẫn dự phòng được kích hoạt. Nhật ký có thể được chú thích bằng ID span và ID dấu vết, giúp dễ dàng tương quan nhật ký và dấu vết từ cùng một phiên người dùng hoặc luồng công việc của tác tử. Mặc dù Loki rất phù hợp cho các nhật ký có cấu trúc, các nhóm yêu cầu tìm kiếm văn bản đầy đủ, các chế độ xem dựa trên vai trò hoặc thông lượng nhập liệu cao hơn cũng có thể xem xét Elasticsearch hoặc các tùy chọn thương mại như nhật ký Datadog hoặc Honeycomb."
    },
    {
      "[y1, x1, y2, x2]": [313, 142, 437, 856],
      "text": "Grafana hợp nhất cả hai luồng dữ liệu này vào một giao diện duy nhất. Nó cung cấp lớp trực quan hóa nơi nhật ký từ Loki và dấu vết từ Tempo có thể được khám phá song song. Trong Grafana, bạn có thể xây dựng các bảng điều khiển hiển thị dữ liệu dấu vết trực tiếp, đi sâu vào các yêu cầu riêng lẻ và tương quan các nhật ký có cấu trúc với các chỉ số hiệu suất. Bạn cũng có thể xây dựng các quy tắc cảnh báo tùy chỉnh—ví dụ, gắn cờ khi tỷ lệ lỗi cho một tác tử cụ thể tăng vọt trên một ngưỡng, hoặc khi độ trễ phản hồi của công cụ vượt qua một ranh giới xác định."
    },
    {
      "[y1, x1, y2, x2]": [453, 142, 560, 856],
      "text": "Cùng nhau, OTel, Tempo, Loki và Grafana tạo thành một bộ công cụ quan sát mã nguồn mở hoàn chỉnh cho các hệ thống tác tử. Chúng cho phép kiểm tra sâu về hành vi, phân tích nguyên nhân gốc rễ nhanh chóng, đánh giá xu hướng lịch sử và phát hiện bất thường chủ động. Sự tích hợp này là thứ biến đo lường từ xa thô thành trí tuệ hoạt động—và trí tuệ hoạt động thành một công cụ tăng tốc phát triển. Khả năng quan sát này cho phép gỡ lỗi thời gian thực, phân tích xu hướng và học hỏi liên tục—tất cả đều cần thiết cho việc triển khai an toàn và có thể mở rộng của các tác tử thông minh trong sản xuất."
    },
    {
      "[y1, x1, y2, x2]": [591, 142, 610, 461],
      "text": "Trực quan hóa và Cảnh báo"
    },
    {
      "[y1, x1, y2, x2]": [627, 142, 717, 856],
      "text": "Một khi các tác tử LangGraph của bạn được đo lường bằng OTel và truyền trực tuyến nhật ký và dấu vết vào Loki và Tempo, lớp cuối cùng và có tác động nhất là trực quan hóa và cảnh báo—được thực hiện nhờ Grafana. Grafana không chỉ là một công cụ tạo bảng điều khiển; nó là giao diện hoạt động cho khả năng quan sát, nơi các tín hiệu trở thành câu chuyện và các chỉ số trở thành hành động."
    },
    {
      "[y1, x1, y2, x2]": [733, 142, 858, 856],
      "text": "Grafana kết nối liền mạch với Loki và Tempo như các nguồn dữ liệu gốc. Đối với các dấu vết, tích hợp Tempo của Grafana cho phép bạn duyệt qua các dấu vết thực thi đầy đủ cho các lần chạy tác tử riêng lẻ. Điều này bao gồm việc xem các hệ thống phân cấp span đại diện cho trình tự và thời gian của các bước mà một tác tử đã thực hiện—từ việc nhận một truy vấn của người dùng đến việc chọn một kế hoạch, gọi các công cụ và soạn thảo đầu ra cuối cùng. Bạn có thể lọc các dấu vết theo độ trễ, trạng thái, tên span hoặc bất kỳ thuộc tính tùy chỉnh nào bạn đã đính kèm trong các nút LangGraph của mình. Điều này là"
    },
    {
      "[y1, x1, y2, x2]": [925, 142, 938, 465],
      "text": "232 | Chương 10: Giám sát trong Môi trường Sản xuất"
    }
  ],
  "page_15": [
    {
      "[y1, x1, y2, x2]": [90, 125, 125, 856],
      "text": "vô giá để gỡ lỗi các hành vi tác tử nhiều bước, đặc biệt là khi hiệu suất suy giảm hoặc các lỗi trường hợp biên phát sinh."
    },
    {
      "[y1, x1, y2, x2]": [141, 142, 231, 856],
      "text": "Đối với nhật ký, plug-in Loki cho phép truy vấn các sự kiện nhật ký có cấu trúc được phát ra trong quá trình thực thi của tác tử. Các bảng nhật ký của Grafana cho phép bạn trực quan hóa nhật ký thời gian thực trên tất cả các tác tử; lọc theo tên tác tử, phiên người dùng, loại lỗi hoặc ID dấu vết; và tương quan nhật ký với các dấu vết liên quan. Bởi vì nhật ký và dấu vết chia sẻ siêu dữ liệu chung—chẳng hạn như ID yêu cầu hoặc phiên—Grafana cho phép bạn chuyển trực tiếp từ một sự tăng đột biến về khối lượng nhật ký hoặc thông báo lỗi đến chính xác dấu vết đã kích hoạt chúng."
    },
    {
      "[y1, x1, y2, x2]": [247, 142, 337, 856],
      "text": "Nhưng sức mạnh thực sự của Grafana nằm ở việc xây dựng các bảng điều khiển phù hợp với ngữ nghĩa và tiêu chí thành công của các tác tử của bạn. Như được minh họa trong Hình 10-1, một bảng điều khiển Quan sát GenAI có thể hiển thị các chỉ số chính như tỷ lệ yêu cầu, chi phí sử dụng, mức tiêu thụ token và phân phối yêu cầu cho các mô hình nền tảng và cơ sở dữ liệu vector. Ví dụ, bạn có thể xây dựng một bảng điều khiển hiển thị những điều sau:"
    },
    {
      "[y1, x1, y2, x2]": [361, 166, 483, 856],
      "list": [
        "Mức sử dụng token cho mỗi tác tử mỗi giờ (để phát hiện sự suy giảm về độ dài dòng của mô hình)",
        "Độ trễ P95 cho các lệnh gọi công cụ và các nút lập kế hoạch",
        "Tỷ lệ thành công của tác vụ theo luồng công việc hoặc phiên bản mẫu câu lệnh",
        "Tần suất dự phòng theo công cụ hoặc kỹ năng",
        "Các chỉ báo trôi dạt dựa trên sự tương đồng embedding của các truy vấn người dùng theo thời gian"
      ]
    },
    {
      "[y1, x1, y2, x2]": [493, 162, 792, 856],
      "image": null
    },
    {
      "[y1, x1, y2, x2]": [800, 142, 885, 856],
      "text": "Hình 10-1. Grafana cho Khả năng quan sát AI. Bảng điều khiển này trực quan hóa các chỉ số chính cho việc sử dụng mô hình ngôn ngữ lớn và cơ sở dữ liệu vector, bao gồm tỷ lệ yêu cầu, số lượng thành công, chi phí, mức tiêu thụ token, thời gian yêu cầu, các mô hình hàng đầu theo mức sử dụng và phân tích theo nền tảng, loại và môi trường, cung cấp những hiểu biết có thể hành động về hiệu suất và hiệu quả của tác tử."
    },
    {
      "[y1, x1, y2, x2]": [925, 642, 938, 856],
      "text": "Trực quan hóa và Cảnh báo | 233"
    }
  ],
  "page_16": [
    {
      "[y1, x1, y2, x2]": [90, 142, 140, 856],
      "text": "Mỗi bảng điều khiển này không chỉ giúp trực quan hóa hiệu suất hệ thống mà còn hướng dẫn quá trình phát triển liên tục. Nếu một công cụ cụ thể bắt đầu thất bại thường xuyên hơn, hoặc nếu việc sử dụng token tăng đột ngột, những tín hiệu này giúp ưu tiên việc gỡ lỗi và tối ưu hóa."
    },
    {
      "[y1, x1, y2, x2]": [156, 142, 209, 856],
      "text": "Grafana cũng hỗ trợ các cảnh báo tùy chỉnh. Bạn có thể xác định các ngưỡng trên bất kỳ chỉ số nào và kích hoạt cảnh báo qua Slack, email, PagerDuty hoặc bất kỳ tích hợp nào khác. Ví dụ, bạn có thể kích hoạt cảnh báo trong các trường hợp sau:"
    },
    {
      "[y1, x1, y2, x2]": [233, 166, 291, 799],
      "list": [
        "Tỷ lệ ảo giác vượt quá 5% trong 30 phút qua",
        "Các vòng lặp thử lại xảy ra hơn ba lần trong một phiên",
        "Thời gian phản hồi trung bình cho một công cụ quan trọng tăng hơn 50%"
      ]
    },
    {
      "[y1, x1, y2, x2]": [308, 142, 361, 856],
      "text": "Các cảnh báo đảm bảo nhóm của bạn nhận thức được các sự suy giảm và bất thường trong thời gian thực, ngay cả khi không có ai đang tích cực theo dõi bảng điều khiển. Kết hợp với nhật ký Loki và dấu vết Tempo, các cảnh báo này giúp đóng vòng lặp phản hồi một cách nhanh chóng."
    },
    {
      "[y1, x1, y2, x2]": [377, 142, 518, 856],
      "text": "Hệ thống cảnh báo của Grafana có khả năng mở rộng cao, tích hợp liền mạch với các công cụ quản lý sự cố phổ biến như PagerDuty để leo thang thông báo đến các nhóm trực—đảm bảo rằng các vấn đề có mức độ nghiêm trọng cao, chẳng hạn như sự tăng đột biến về tỷ lệ ảo giác hoặc lỗi tác vụ, kích hoạt các luồng công việc phản ứng có cấu trúc với việc phân trang và xác nhận tự động. Để giám sát lỗi chuyên biệt hơn, Sentry có thể được xếp lớp để ghi lại và phân tích các ngoại lệ trong mã tác tử, cung cấp dấu vết ngăn xếp, breadcrumbs và các chỉ số sức khỏe phiên bản bổ sung cho các bảng điều khiển của Grafana; điều này đặc biệt hữu ích để gỡ lỗi các lỗi xác suất trong các lệnh gọi mô hình nền tảng hoặc các lệnh gọi công cụ, với SDK của Sentry dễ dàng được đo lường cùng với OTel."
    },
    {
      "[y1, x1, y2, x2]": [534, 142, 675, 856],
      "text": "Đối với các nhóm tìm kiếm một giải pháp tất cả trong một được thiết kế riêng cho các hệ thống tác tử, các nền tảng như AgentOps.ai cung cấp một giải pháp thay thế hợp lý, kết hợp truy vết, chỉ số, đánh giá và cảnh báo trong một gói duy nhất được tối ưu hóa cho các mô hình nền tảng và tác tử. AgentOps.ai xử lý giám sát ngữ nghĩa (ví dụ: tự động chấm điểm chất lượng đầu ra) và tích hợp với các bộ công cụ hiện có, giảm chi phí thiết lập so với việc soạn thảo các thành phần Grafana—mặc dù nó có thể gây ra sự phụ thuộc vào nhà cung cấp. Các tùy chọn này tạo ra sự linh hoạt: mở rộng Grafana với PagerDuty/Sentry để có cảnh báo mạnh mẽ, hoặc áp dụng AgentOps.ai để có những hiểu biết cụ thể về tác tử nhanh hơn, tùy thuộc vào sự trưởng thành và trọng tâm hoạt động của bạn."
    },
    {
      "[y1, x1, y2, x2]": [691, 142, 781, 856],
      "text": "Bằng cách tích hợp sâu Grafana vào vòng đời phát triển tác tử của bạn, bạn tạo ra một giao diện sống động cho các hệ thống được triển khai của mình. Nó trở thành bức tranh chung nơi các nhóm sản phẩm, kỹ sư và nhân viên độ tin cậy có thể quan sát, gỡ lỗi, lặp lại và cải tiến. Trong thế giới của các hệ thống dựa trên tác tử—nơi các lỗi là xác suất và các chế độ thất bại là mới nổi—loại khả năng hiển thị thống nhất này không chỉ là một điều tốt đẹp. Nó là điều cần thiết."
    },
    {
      "[y1, x1, y2, x2]": [925, 142, 938, 465],
      "text": "234 | Chương 10: Giám sát trong Môi trường Sản xuất"
    }
  ],
  "page_17": [
    {
      "[y1, x1, y2, x2]": [83, 142, 102, 411],
      "text": "Các Mẫu Giám sát"
    },
    {
      "[y1, x1, y2, x2]": [119, 142, 226, 856],
      "text": "Một khi một bộ công cụ quan sát đã được thiết lập—bao gồm đo lường, nhật ký, dấu vết, bảng điều khiển và cảnh báo—câu hỏi đặt ra là: làm thế nào để chúng ta vận chuyển các thay đổi một cách an toàn đến các hệ thống tác tử vốn có bản chất xác suất, thích ứng và khó dự đoán đầy đủ? Câu trả lời nằm ở việc áp dụng các mẫu phát triển nhận thức về giám sát giúp giảm rủi ro thử nghiệm và tạo ra các lưới an toàn xung quanh các thay đổi sản xuất. Trong phần này, chúng tôi khám phá một số mẫu chính mà các nhóm có thể áp dụng để đảm bảo các tác tử của họ tiếp tục phát triển một cách an toàn và phản ứng nhanh."
    },
    {
      "[y1, x1, y2, x2]": [257, 142, 276, 319],
      "text": "Chế độ Bóng tối"
    },
    {
      "[y1, x1, y2, x2]": [293, 142, 364, 856],
      "text": "Trong chế độ bóng tối, một phiên bản mới hoặc thử nghiệm của một tác tử chạy song song với tác tử sản xuất hiện tại, xử lý cùng một đầu vào nhưng không phục vụ đầu ra của nó cho người dùng. Điều này cho phép các nhà phát triển ghi lại và truy vết hành vi của tác tử mới trong các điều kiện thực tế mà không ảnh hưởng đến trải nghiệm người dùng."
    },
    {
      "[y1, x1, y2, x2]": [380, 142, 470, 856],
      "text": "Với OTel, bạn có thể đo lường cả tác tử sản xuất và tác tử bóng tối và đính kèm một ID yêu cầu chung. Nhật ký và dấu vết từ tác tử bóng tối sau đó có thể được gắn nhãn tương ứng trong Loki và Tempo, giúp dễ dàng so sánh hành vi. Bạn có thể xem xét sự khác biệt trong việc lựa chọn công cụ, độ trễ, việc sử dụng token hoặc tần suất ảo giác. Những so sánh này đặc biệt hữu ích khi thử nghiệm các phiên bản mô hình mới, các chiến lược lập kế hoạch hoặc các kỹ thuật gợi ý."
    },
    {
      "[y1, x1, y2, x2]": [486, 142, 539, 856],
      "text": "Chế độ bóng tối cho phép đổi mới an toàn hơn. Nó cho phép các nhóm trả lời: tác tử mới hoạt động tốt hơn hay tệ hơn trên lưu lượng truy cập trực tiếp? Điều gì bị hỏng? Điều gì được cải thiện? Và nó cho phép bạn thu thập dữ liệu này liên tục, song song với hoạt động bình thường."
    },
    {
      "[y1, x1, y2, x2]": [570, 142, 589, 411],
      "text": "Triển khai Canary"
    },
    {
      "[y1, x1, y2, x2]": [606, 142, 662, 856],
      "text": "Trong khi chế độ bóng tối thu thập thông tin mà không tiếp xúc, canarying đi một bước xa hơn. Một triển khai canary phục vụ một phiên bản tác tử mới cho một tập hợp nhỏ người dùng thực—giả sử, 1% hoặc 5% lưu lượng truy cập—trong khi phần lớn người dùng tiếp tục tương tác với phiên bản cơ sở."
    },
    {
      "[y1, x1, y2, x2]": [678, 142, 748, 856],
      "text": "Các bảng điều khiển Grafana rất quan trọng trong thiết lập này. Bằng cách lọc tất cả các chỉ số và dấu vết theo thẻ phiên bản, bạn có thể so sánh trực tiếp tỷ lệ thành công, độ trễ, việc sử dụng công cụ và số lượng lỗi giữa các tác tử canary và cơ sở. Các cảnh báo có thể được cấu hình để kích hoạt nếu canary cho thấy sự suy giảm hoặc bất thường đáng kể."
    },
    {
      "[y1, x1, y2, x2]": [764, 142, 817, 856],
      "text": "Nếu canary hoạt động tốt, việc triển khai có thể được mở rộng dần dần. Nếu không, nó có thể được quay trở lại ngay lập tức với tác động tối thiểu đến người dùng. Canarying cung cấp sự an toàn hoạt động cần thiết để lặp lại nhanh chóng trong môi trường sản xuất."
    },
    {
      "[y1, x1, y2, x2]": [925, 678, 938, 856],
      "text": "Các Mẫu Giám sát | 235"
    }
  ],
  "page_18": [
    {
      "[y1, x1, y2, x2]": [83, 142, 102, 480],
      "text": "Thu thập Dấu vết Hồi quy"
    },
    {
      "[y1, x1, y2, x2]": [119, 142, 189, 856],
      "text": "Mỗi khi một tác tử thất bại trong sản xuất—cho dù thông qua ảo giác, lỗi lập kế hoạch hay sử dụng sai công cụ—nó tạo ra một cơ hội để học hỏi. Bằng cách tự động xuất các dấu vết thất bại này (từ Tempo) hoặc các ảnh chụp nhật ký (từ Loki) vào bộ kiểm thử của bạn, bạn xây dựng một kho hồi quy được cập nhật liên tục."
    },
    {
      "[y1, x1, y2, x2]": [205, 142, 275, 856],
      "text": "Điều này biến các thất bại sản xuất thành các tín hiệu đào tạo. Một lệnh gọi công cụ thất bại hoặc một đầu ra không phù hợp trở thành một trường hợp kiểm thử mới. Một khi một bản sửa lỗi được triển khai, việc chạy lại dấu vết này sẽ phải thành công. Theo thời gian, chiến lược này củng cố bộ đánh giá của bạn với các trường hợp biên thực tế và giúp ngăn chặn sự tái diễn của các chế độ thất bại tương tự."
    },
    {
      "[y1, x1, y2, x2]": [298, 142, 317, 376],
      "text": "Các Tác tử Tự chữa lành"
    },
    {
      "[y1, x1, y2, x2]": [334, 142, 387, 856],
      "text": "Cuối cùng, giám sát có thể làm nhiều hơn là chỉ phát hiện thất bại—nó có thể giúp các tác tử phục hồi từ đó. Các tác tử được thiết kế để đọc đo lường từ xa của chính chúng trong thời gian thực có thể triển khai các cơ chế dự phòng khi các vấn đề được phát hiện."
    },
    {
      "[y1, x1, y2, x2]": [403, 142, 473, 856],
      "text": "Ví dụ, nếu một lệnh gọi công cụ thất bại liên tục, tác tử có thể chuyển hướng đến một kế hoạch dự phòng đơn giản hơn hoặc yêu cầu người dùng làm rõ. Nếu độ trễ tăng vọt, tác tử có thể bỏ qua các bước suy luận tùy chọn. Nếu điểm số ảo giác cao, nó có thể đưa ra một tuyên bố từ chối trách nhiệm hoặc chuyển giao cho con người xem xét."
    },
    {
      "[y1, x1, y2, x2]": [489, 142, 542, 856],
      "text": "Những hành vi tự chữa lành này hiệu quả nhất khi được hỗ trợ bởi dữ liệu giám sát chi tiết. Mỗi quyết định dự phòng có thể được ghi lại và truy vết, cho phép các nhóm phân tích khi nào và tại sao các phương án dự phòng được kích hoạt, và liệu chúng có giúp giải quyết vấn đề hay không."
    },
    {
      "[y1, x1, y2, x2]": [565, 142, 584, 631],
      "text": "Phản hồi của Người dùng như một Tín hiệu Quan sát"
    },
    {
      "[y1, x1, y2, x2]": [601, 142, 691, 856],
      "text": "Mặc dù phần lớn chương này đã tập trung vào nhật ký, dấu vết và chỉ số, phản hồi của người dùng cung cấp một lăng kính bổ sung—cái nhìn sâu sắc trực tiếp về mức độ tác tử đáp ứng kỳ vọng của con người. Phản hồi có thể là ngầm, chẳng hạn như người dùng diễn đạt lại đầu vào của họ, từ bỏ nhiệm vụ hoặc do dự trong các tương tác. Nó cũng có thể là rõ ràng, như một biểu tượng không thích, một đánh giá sao hoặc một bình luận văn bản tự do. Cả hai hình thức đều cung cấp các tín hiệu thời gian thực có thể và nên được tích hợp vào bộ công cụ giám sát của bạn."
    },
    {
      "[y1, x1, y2, x2]": [707, 142, 814, 856],
      "text": "Trong thực tế, các chỉ số phản hồi ngầm—chẳng hạn như tỷ lệ từ bỏ nhiệm vụ hoặc tần suất truy vấn lại—có thể được ghi lại và tổng hợp trong Loki và được trực quan hóa trong Grafana giống như bất kỳ chỉ số hiệu suất nào khác. Chúng cung cấp các chỉ báo sớm về sự ma sát hoặc nhầm lẫn. Các sự kiện phản hồi rõ ràng, như xếp hạng thấp, có thể được gắn với các dấu vết cụ thể trong Tempo và kích hoạt cảnh báo khi sự không hài lòng tăng đột biến. Các bảng điều khiển kết hợp các chỉ số cảm tính của người dùng với dữ liệu kỹ thuật dựa trên dấu vết cho phép các nhóm tương quan các vấn đề hiệu suất với sự thất vọng của người dùng, mang lại một bức tranh đầy đủ hơn về sức khỏe của tác tử."
    },
    {
      "[y1, x1, y2, x2]": [830, 142, 866, 856],
      "text": "Quan trọng là, phản hồi của người dùng cũng có thể thúc đẩy các vòng lặp cải tiến. Ví dụ, các dấu vết liên quan đến xếp hạng thấp có thể được xuất trực tiếp vào bộ đánh giá để phân tích sau đó."
    },
    {
      "[y1, x1, y2, x2]": [925, 142, 938, 465],
      "text": "236 | Chương 10: Giám sát trong Môi trường Sản xuất"
    }
  ],
  "page_19": [
    {
      "[y1, x1, y2, x2]": [90, 142, 157, 856],
      "text": "đánh giá. Nếu nhiều người dùng từ bỏ một luồng cụ thể, điều đó có thể đảm bảo việc xem xét lại chiến lược lập kế hoạch hoặc đào tạo lại câu lệnh của mô hình nền tảng. Bằng cách tích hợp các tín hiệu của người dùng vào khung quan sát và hành động rộng lớn hơn, các nhóm đảm bảo các phương pháp giám sát của họ không chỉ hiệu quả về mặt hoạt động mà còn lấy người dùng làm trung tâm."
    },
    {
      "[y1, x1, y2, x2]": [188, 142, 207, 401],
      "text": "Sự thay đổi Phân phối"
    },
    {
      "[y1, x1, y2, x2]": [224, 142, 314, 856],
      "text": "Một trong những thách thức tinh vi nhất, nhưng cũng quan trọng nhất, trong việc giám sát các hệ thống dựa trên tác tử là xác định và quản lý sự thay đổi phân phối. Những điều này xảy ra khi các thuộc tính thống kê của môi trường của tác tử thay đổi theo thời gian—cho dù thông qua ngôn ngữ người dùng đang phát triển, thuật ngữ sản phẩm mới, thay đổi trong phản hồi API, hoặc thậm chí là các bản cập nhật cho chính mô hình nền tảng. Mặc dù những thay đổi như vậy có thể không gây ra lỗi rõ ràng, chúng thường biểu hiện dưới dạng hiệu suất suy giảm, đầu ra không phù hợp hoặc việc sử dụng dự phòng tăng lên."
    },
    {
      "[y1, x1, y2, x2]": [330, 142, 490, 856],
      "text": "Các hệ thống giám sát là tuyến phòng thủ đầu tiên của bạn chống lại loại trôi dạt chậm này. Các bảng điều khiển theo dõi tỷ lệ thành công của tác vụ, các lỗi gọi công cụ và các chỉ số ngữ nghĩa—chẳng hạn như xu hướng sử dụng token hoặc tần suất ảo giác—có thể làm nổi bật các tín hiệu sớm. Để phát hiện định lượng, hãy sử dụng các bài kiểm tra thống kê như kiểm tra Kolmogorov-Smirnov (KS) để so sánh phân phối của các đặc trưng đầu vào hoặc đầu ra. Kiểm tra KS là một bài kiểm tra thống kê phi tham số so sánh các hàm phân phối tích lũy thực nghiệm của hai bộ dữ liệu để xác định xem chúng có được rút ra từ cùng một phân phối cơ bản hay không, làm cho nó trở nên lý tưởng để phát hiện sự thay đổi trong các đặc trưng liên tục như độ dài truy vấn, độ trễ hoặc các chỉ số số mà không cần giả định tính chuẩn. Nó tính toán khoảng cách dọc tối đa (thống kê KS) giữa các phân phối, cùng với một giá trị p cho ý nghĩa thống kê; các ngưỡng như KS > 0.1 (thường được kết hợp với giá trị p < 0.05) cho thấy sự phân kỳ có ý nghĩa, kích hoạt cảnh báo về sự trôi dạt tiềm năng trong đầu vào hoặc đầu ra của tác tử."
    },
    {
      "[y1, x1, y2, x2]": [493, 142, 546, 856],
      "text": "Trong đoạn mã này, hàm ks_2samp của SciPy được áp dụng cho các mảng mẫu của dữ liệu lịch sử và hiện tại, in ra một thông báo phát hiện nếu thống kê vượt quá ngưỡng. Dưới đây là một ví dụ Python nhỏ sử dụng SciPy để phát hiện sự trôi dạt trong độ dài truy vấn:"
    },
    {
      "[y1, x1, y2, x2]": [569, 179, 711, 677],
      "code": "import numpy as np\nfrom scipy import stats\n\n# Độ dài truy vấn lịch sử và hiện tại (ví dụ: số ký tự)\nhistorical = np.array([10, 15, 20, 12]) # Dữ liệu cơ sở\ncurrent = np.array([25, 30, 28, 35])\n# Dữ liệu mới\n\nks_stat, p_value = stats.ks_2samp(historical, current)\nif ks_stat > 0.1:\n    print(f\"Phát hiện trôi dạt: Thống kê KS = {ks_stat}\")"
    },
    {
      "[y1, x1, y2, x2]": [727, 142, 817, 856],
      "text": "Phân kỳ Kullback-Leibler (KL) đo lường mức độ một phân phối xác suất phân kỳ so với một phân phối khác, thường được sử dụng để phát hiện sự trôi dạt khái niệm bằng cách định lượng sự thay đổi trong phân phối token (ví dụ: thay đổi tần suất từ có thể chỉ ra ngôn ngữ người dùng đang phát triển hoặc thuật ngữ mới). Nó không đối xứng KL(P||Q) ≠ KL(Q||P) và có thể báo hiệu khi dữ liệu hiện tại (Q) lệch đáng kể so với các đường cơ sở lịch sử (P), với các giá trị cao hơn"
    },
    {
      "[y1, x1, y2, x2]": [925, 691, 938, 856],
      "text": "Sự thay đổi Phân phối | 237"
    }
  ],
  "page_20": [
    {
      "[y1, x1, y2, x2]": [90, 142, 157, 856],
      "text": "cho thấy sự trôi dạt lớn hơn—ví dụ, một ngưỡng > 0.5 có thể gắn cờ các thay đổi khái niệm trong các embedding. Trong đoạn mã này, chúng tôi chuẩn hóa các vector tần suất thành xác suất, thêm một epsilon nhỏ để tránh lỗi log(0) và tính tổng của P * log(P/Q); ví dụ giả định các mảng đếm token đơn giản hóa cho dữ liệu lịch sử và hiện tại:"
    },
    {
      "[y1, x1, y2, x2]": [172, 179, 381, 665],
      "code": "import numpy as np\n\ndef kl_divergence(p, q, epsilon=1e-10):\n    p = p + epsilon\n    q = q + epsilon\n    p = p / np.sum(p)\n    q = q / np.sum(q)\n    return np.sum(p * np.log(p / q))\n\n# Vector tần suất token (ví dụ: số lượng [từ1, từ2, ...])\nhistorical_tokens = np.array([0.4, 0.3, 0.3])\ncurrent_tokens = np.array([0.2, 0.5, 0.3])\n\nkl = kl_divergence(historical_tokens, current_tokens)\nif kl > 0.5:\n    print(f\"Phát hiện trôi dạt khái niệm: KL = {kl}\")"
    },
    {
      "[y1, x1, y2, x2]": [397, 142, 560, 856],
      "text": "Chỉ số ổn định dân số (PSI) là một chỉ số để phát hiện sự thay đổi trong các biến phân loại hoặc các biến liên tục được chia thành các khoảng (ví dụ: các loại sử dụng công cụ như “hoàn tiền,” “hủy,” “sửa đổi”) bằng cách so sánh phân phối phần trăm giữa các bộ dữ liệu lịch sử và hiện tại, thường được chia thành các nhóm để phân tích chi tiết. Nó tính tổng logarit_tự_nhiên(phần_trăm_thực_tế / phần_trăm_dự_kiến) trên các loại, trong đó PSI thấp (< 0.1) có nghĩa là ổn định, 0.1–0.25 cho thấy sự trôi dạt nhỏ (theo dõi) và > 0.25 báo hiệu sự trôi dạt lớn (can thiệp—ví dụ: đào tạo lại). Điều này giúp gắn cờ các thay đổi trong các mẫu mà không cần giả định tính chuẩn, làm cho nó phù hợp với các chỉ số của tác tử như tần suất gọi:"
    },
    {
      "[y1, x1, y2, x2]": [575, 179, 860, 672],
      "code": "import numpy as np\n\ndef psi(expected, actual):\n    expected_percents = expected / np.sum(expected)\n    actual_percents = actual / np.sum(actual)\n    psi_values = ((actual_percents - expected_percents) *\n        np.log(actual_percents / expected_percents))\n    return np.sum(psi_values)\n\n# Số lần sử dụng công cụ (ví dụ: ['hoàn tiền', 'hủy', 'sửa đổi'])\nhistorical = np.array([50, 30, 20])\ncurrent = np.array([20, 50, 30])\n\npsi_value = psi(historical, current)\nif psi_value > 0.25:\n    print(f\"Trôi dạt lớn: PSI = {psi_value}\")\nelif psi_value > 0.1:\n    print(f\"Trôi dạt nhỏ: PSI = {psi_value}\")"
    },
    {
      "[y1, x1, y2, x2]": [925, 142, 938, 465],
      "text": "238 | Chương 10: Giám sát trong Môi trường Sản xuất"
    }
  ]
}