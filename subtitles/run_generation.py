import os
from dotenv import load_dotenv
from subtitles.gemini_utils import generate_and_save # Assuming same level import

# Load environment variables from .env file
load_dotenv()

def main():
    api_key = os.environ.get("GEMINI_API_KEY")
    if not api_key:
        print("Error: GEMINI_API_KEY not found in environment variables.")
        print("Please create a .env file with GEMINI_API_KEY='YOUR_API_KEY_HERE'")
        return

    # --- Configuration ---
    # This input_text would typically be loaded from the output of input_manipulation.py
    # For demonstration, a very short version is used here.
    input_text = """
    [
      {
        "5FDL": "This is the first segment. (Wt) It has some content. (lH) And more. (am)"
      },
      {
        "gd0j": "This is the second segment, (sE) continuing the story. (wj) The end. (II)"
      }
    ]
    """
    # The actual text sent to Gemini for translation would be the concatenation of values:
    # "This is the first segment. (Wt) It has some content. (lH) And more. (am) This is the second segment, (sE) ..."
    # The keys '5FDL', 'gd0j' are used to segment Gemini's translated output.

    # For the gemini_utils.generate_and_save, the input_text should be a single string
    # that represents the content to be translated, which might be the concatenation
    # of all "text" fields from the structure generated by input_manipulation.py.
    # Let's assume input_manipulation.py output a JSON with keys and segments,
    # and here we'd reconstruct the full string to send for translation.
    # For this example, we'll simulate that full string based on the above structure.
    
    # Constructing the text to be sent to Gemini (concatenation of values from the JSON)
    # In a real workflow, you'd parse the JSON from input_manipulation.py
    example_input_structure = [
      {"5FDL": "This is the first segment. (Wt) It has some content. (lH) And more. (am)"},
      {"gd0j": "This is the second segment, (sE) continuing the story. (wj) The end. (II)"}
    ]
    full_text_to_translate = " ".join(list(item.values())[0] for item in example_input_structure)


    output_filename = "generated_output.txt"
    
    # Define the keys for segmentation (these should match the keys in your structured input)
    generated_keys = ['5FDL', 'gd0j'] 
    # generated_keys = ['o1Bq'] # Test single key
    # generated_keys = []      # Test no keys

    context_characters = 150 # Or load from a config

    # Call the generation function
    generate_and_save(full_text_to_translate, output_filename, api_key, generated_keys, context_chars_for_regex=context_characters)

if __name__ == "__main__":
    main()
