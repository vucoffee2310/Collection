document.addEventListener('DOMContentLoaded', () => {
    // --- State Variable ---
    let generatedCommand = '';

    // --- Element Selectors ---
    const copyCommandButton = document.getElementById('copy-command-btn');
    const sendApiButton = document.getElementById('send-api-btn');
    const apiResponseElement = document.getElementById('api-response');
    const settingsForm = document.getElementById('settings-form');
    const httpChunkSizeInput = document.getElementById('http-chunk-size');
    const limitRateInput = document.getElementById('limit-rate');
    const playerClientSelect = document.getElementById('player-client');
    const playbackWaitInput = document.getElementById('playback-wait');

    // --- Data Store ---
    let dynamicData = { tabUrl: null, poToken: null, cookies: [] };
    const YOUTUBE_COOKIE_NAMES = new Set(['__Secure-1PAPISID', '__Secure-1PSID', '__Secure-1PSIDCC', '__Secure-1PSIDTS', '__Secure-3PAPISID', '__Secure-3PSID', '__Secure-3PSIDCC', '__Secure-3PSIDTS']);
    
    // --- Helper Functions ---
    function formatCookiesForShell(cookies) {
        const header = "# Netscape HTTP Cookie File\\n# Generated by yt-dlp Command Helper\\n\\n";
        const cookieLines = cookies.map(cookie => {
            const safeValue = cookie.value.replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/\$/g, '\\$').replace(/`/g, '\\`');
            return `${cookie.domain}\\t${cookie.hostOnly ? 'FALSE' : 'TRUE'}\\t${cookie.path}\\t${cookie.secure ? 'TRUE' : 'FALSE'}\\t${cookie.expirationDate ? Math.floor(cookie.expirationDate) : 0}\\t${cookie.name}\\t${safeValue}`;
        });
        return header + cookieLines.join('\\n');
    }

    function formatCookiesForApi(cookies) {
        const header = "# Netscape HTTP Cookie File\n# Generated by yt-dlp Command Helper\n\n";
        const cookieLines = cookies.map(c => [c.domain, c.hostOnly ? 'FALSE' : 'TRUE', c.path, c.secure ? 'TRUE' : 'FALSE', c.expirationDate ? Math.floor(c.expirationDate) : 0, c.name, c.value].join('\t'));
        return header + cookieLines.join('\n');
    }

    function buildCommandString(settings, shellFormattedCookies) {
        const { tabUrl, poToken } = dynamicData;
        const { httpChunkSize, limitRate, playerClient, playbackWait } = settings;
        const poTokenPrefix = `${playerClient}.gvs+`;
        const formatString = `-f ba -S "+abr,+tbr,+size"`;

        return `echo -e "${shellFormattedCookies}" > cookies.txt && yt-dlp ${formatString} --http-chunk-size ${httpChunkSize}M --limit-rate ${limitRate}M --cookies cookies.txt --extractor-args "youtube:playback_wait=${playbackWait};player_client=${playerClient};po_token=${poTokenPrefix}${poToken}" "${tabUrl}"`;
    }

    async function sendApiRequest(requestData) {
        const API_URL = 'https://ytdlpy.vercel.app/';
        try {
            const response = await fetch(API_URL, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(requestData) });
            if (!response.ok) {
                const errorBody = await response.text();
                throw new Error(`API returned status ${response.status}: ${errorBody || response.statusText}`);
            }
            return await response.json();
        } catch (error) {
            console.error('Error sending API request:', error);
            throw error;
        }
    }

    function updateUiState() {
        const currentSettings = {
            httpChunkSize: httpChunkSizeInput.value,
            limitRate: limitRateInput.value,
            playerClient: playerClientSelect.value,
            playbackWait: playbackWaitInput.value
        };

        const isDataReady = dynamicData.cookies.length > 0 && dynamicData.poToken && dynamicData.tabUrl;

        if (isDataReady) {
            const shellFormattedCookies = formatCookiesForShell(dynamicData.cookies);
            generatedCommand = buildCommandString(currentSettings, shellFormattedCookies);
            copyCommandButton.disabled = false;
            sendApiButton.disabled = false;
        } else {
            generatedCommand = '';
            copyCommandButton.disabled = true;
            sendApiButton.disabled = true;
        }
    }
    
    async function initialize() {
        const { settings } = await chrome.storage.local.get('settings');
        const defaults = { httpChunkSize: 8, limitRate: 4, playerClient: 'tv', playbackWait: 2 };
        const currentSettings = { ...defaults, ...settings };

        httpChunkSizeInput.value = currentSettings.httpChunkSize;
        limitRateInput.value = currentSettings.limitRate;
        playerClientSelect.value = currentSettings.playerClient;
        playbackWaitInput.value = currentSettings.playbackWait;

        const [tab] = await chrome.tabs.query({ active: true, currentWindow: true });
        if (!tab || !tab.url || !tab.url.startsWith("https://www.youtube.com/")) {
            apiResponseElement.textContent = "Error: Not a YouTube page.";
            return;
        }
        dynamicData.tabUrl = tab.url;

        const allCookies = await chrome.cookies.getAll({ url: tab.url });
        const filteredCookies = allCookies.filter(c => YOUTUBE_COOKIE_NAMES.has(c.name));
        if (filteredCookies.length < YOUTUBE_COOKIE_NAMES.size) {
            apiResponseElement.textContent = `Error: Missing ${YOUTUBE_COOKIE_NAMES.size - filteredCookies.length} required cookies. Please log in to YouTube.`;
            return;
        }
        dynamicData.cookies = filteredCookies;

        const storageResult = await chrome.storage.local.get([tab.id.toString()]);
        const requests = storageResult[tab.id.toString()] || [];
        const lastRequestWithToken = [...requests].reverse().find(r => r.poToken);
        if (lastRequestWithToken) {
            dynamicData.poToken = lastRequestWithToken.poToken;
        } else {
            apiResponseElement.textContent = 'Error: poToken not found. Please refresh the YouTube page.';
            return;
        }
        
        updateUiState();
    }

    // --- Event Listeners ---
    settingsForm.addEventListener('input', () => {
        const currentSettings = { httpChunkSize: httpChunkSizeInput.value, limitRate: limitRateInput.value, playerClient: playerClientSelect.value, playbackWait: playbackWaitInput.value };
        chrome.storage.local.set({ settings: currentSettings });
        updateUiState();
    });
    
    copyCommandButton.addEventListener('click', () => {
        if (copyCommandButton.disabled || !generatedCommand) return;
        navigator.clipboard.writeText(generatedCommand).then(() => {
            copyCommandButton.textContent = 'Copied!';
            setTimeout(() => { copyCommandButton.textContent = 'Copy'; }, 2000);
        });
    });

    sendApiButton.addEventListener('click', async () => {
        if (sendApiButton.disabled) return;
        
        sendApiButton.disabled = true;
        apiResponseElement.textContent = 'Sending request...';

        try {
            const settings = { httpChunkSize: httpChunkSizeInput.value, limitRate: limitRateInput.value, playerClient: playerClientSelect.value, playbackWait: playbackWaitInput.value };
            const requestData = {
                url: dynamicData.tabUrl,
                cookies: formatCookiesForApi(dynamicData.cookies),
                po_token: `${settings.playerClient}.gvs+${dynamicData.poToken}`,
                yt_dlp_options: {
                  format: "ba",
                  sort_order: "+abr,+tbr,+size",
                  http_chunk_size: `${settings.httpChunkSize}M`,
                  limit_rate: `${settings.limitRate}M`
                },
                extractor_args: {
                  player_client: settings.playerClient,
                  playback_wait: settings.playbackWait
                }
            };

            const responseData = await sendApiRequest(requestData);
            apiResponseElement.textContent = JSON.stringify(responseData, null, 2);

        } catch (error) {
            apiResponseElement.textContent = `Error: ${error.message}`;
        } finally {
            // Re-enable the button if it's still part of the DOM
            if (document.body.contains(sendApiButton)) {
               sendApiButton.disabled = false;
            }
        }
    });

    initialize();
});