<!DOCTYPE html>
<html lang="en">
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Segment Mapper</title>
    <link rel="stylesheet" href="css/base.css">
    <link rel="stylesheet" href="css/layout.css">
    <link rel="stylesheet" href="css/components.css">
    <link rel="stylesheet" href="css/widgets.css">
    <link rel="stylesheet" href="css/mapping.css">
</head>
<body>
    <!-- REPLACE THIS ENTIRE SECTION -->
    <div class="header">
        <h1>AI Segment Mapper</h1>
        <div style="display: flex; gap: 10px;">
            <button id="openDebugWindow" style="background: #9b59b6; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer; font-weight: 600;">
                ðŸ”¬ Open Process Debug Window
            </button>
            <button id="btn">Generate & Map</button>
        </div>
    </div>
    <!-- END OF REPLACEMENT -->
    
    <div class="main-container">
        <div class="content-column">
            <div class="panel">
                <div class="input-group">
                    <h3>Source Input (Full Prompt for AI)</h3>
                    <textarea class="input-area" id="sourceInput">Translate to Vietnamese

```
---
url:https://github.com/0342/
---
(u) Hi guys, welcome back. And today in this video, we're going to talk about Testbrite, an AI agent which can write software test code for us without us writing even a single line of code. We (a) already talked about test sprite in our earlier videos where we saw how we can pass the URL of our API or maybe the UI application and then test pride can generate the test for us and you can (w) also interact with Testbrite by just asking questions on the chat and everything is going to work for you. But now today we are going to see how test sprite's new MCP feature is going to (n) leverage the power of the artificial intelligence a level further and also with the agents a level further where you can write the test automation code in a more robust fashion. So basically (u) using this test sprite MCP server you are going to let your AI to code and every single operation is going to be taken care by the test sprite itself. So this test sprite MCP server is not only (c) just going to write test code for you. It is also going to help you debugging your test code. I'll tell you what I really mean about that. We know that test sprite MCP server always run the (c) application which is hosted on the cloud machine. But what if your application is running within your local machine and you wanted to test the application which is hosted in your local machine or in (o) within your company. So how can we actually do that? Well, the answer for this is the test MCP server. And what if you wanted to generate the report of the test execution right from your local (e) machine instead of going to the actual test brite portal itself. The answer is this test MCP server is going to do it for you using its tooling options available. And also what if you wanted (l) to debug the test which is failing because of the test execution. And if you want to fix the code right from your local machine, test MCP server is going to be the answer. And finally, what if (v) you want to generate the test script locally and also store them all in a local codebase? Testrite MCP server is going to do that for you. So in a nutshell, the workflow of the Testbrite (t) MCP server is going to look something like this. The Testbrite MCP server as like any model contest protocol server is going to be configured within your famous IDE like cursor IDE or GitHub (k) copilot or even Vinserve whatever that you name it. whichever ID supports the MCP server.
```</textarea>
                </div>
            </div>
            <div class="panel">
                <h2>AI-Generated Segment Mapping</h2>
                <div id="display"></div>
            </div>
        </div>
        <div class="sidebar-column">
            <div class="panel">
                <h3>Logs</h3>
                <div id="log-display" class="log-panel"></div>
            </div>
            <div class="panel">
                <h3>Request & Response Details</h3>
                <details>
                    <summary>Request Object</summary>
                    <pre id="request-details" class="details-pre"></pre>
                </details>
                <details open>
                    <summary>Request Data (Payload)</summary>
                    <pre id="request-data" class="details-pre"></pre>
                </details>
                <details>
                    <summary>Network Response Object</summary>
                    <pre id="network-response-details" class="details-pre"></pre>
                </details>
                <details open>
                    <summary>Generation Summary</summary>
                    <pre id="generation-summary" class="details-pre"></pre>
                </details>
                <details open>
                    <summary>Response Data (Streamed)</summary>
                    <pre id="response-data-stream" class="details-pre stream-data"></pre>
                </details>
            </div>
        </div>
    </div>
    <script src="js/app.js" type="module"></script>
</body>
</html>